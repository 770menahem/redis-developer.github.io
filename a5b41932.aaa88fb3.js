(window.webpackJsonp=window.webpackJsonp||[]).push([[191],{262:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return l})),n.d(t,"toc",(function(){return o})),n.d(t,"default",(function(){return d}));var a=n(3),r=n(7),i=(n(0),n(364)),s={id:"index-redis-functions",title:"Getting started with Redis Functions",sidebar_label:"Redis Functions",slug:"/create/redis-functions",authors:["elena"]},l={unversionedId:"create/redis-functions/index-redis-functions",id:"create/redis-functions/index-redis-functions",isDocsHomePage:!1,title:"Getting started with Redis Functions",description:"Getting started with Redis Functions",source:"@site/docs/create/redis-functions/index-redis-functions.mdx",slug:"/create/redis-functions",permalink:"/create/redis-functions",editUrl:"https://github.com/redis-developer/redis-developer/edit/master/docs/create/redis-functions/index-redis-functions.mdx",version:"current",lastUpdatedAt:1652433951,sidebar_label:"Redis Functions",sidebar:"docs",previous:{title:"Introduction to Redis Stack",permalink:"/create/redis-stack"},next:{title:"Create database using Redis Enterprise Cloud",permalink:"/create/rediscloud"}},o=[{value:"Environment setup",id:"environment-setup",children:[]},{value:"Warm-Up",id:"warm-up",children:[]},{value:"Maintaining a consistent view of data entities through a logical schema",id:"maintaining-a-consistent-view-of-data-entities-through-a-logical-schema",children:[]},{value:"Thinking ahead",id:"thinking-ahead",children:[]},{value:"Refactoring",id:"refactoring",children:[]},{value:"Using Function flags",id:"using-function-flags",children:[]}],c={toc:o};function d(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h1",{id:"getting-started-with-redis-functions"},"Getting started with Redis Functions"),Object(i.b)("p",null,"The most impactful addition to Redis version 7.0 is ",Object(i.b)("strong",{parentName:"p"},"Redis Functions")," - a new programmability option, improving on scripts by ",Object(i.b)("strong",{parentName:"p"},"adding modularity, reusability, and better overall developer experience"),". "),Object(i.b)("p",null,"Functions are, in contrast to scripts, persisted in the .rdb and .aof files as well as automatically replicated to all the replicas, which makes them a first-class citizen of Redis."),Object(i.b)("p",null,"Redis has the capability of supporting multiple execution engines so in one of the future releases we\u2019ll be able to write Redis Functions in Lua, Javascript, and more languages, but at the moment (Redis v7.0) the only supported language is Lua."),Object(i.b)("p",null,"A common pain point for developers is to maintain a consistent view of data entities through a logical schema. Redis Functions are ideally suited for solving this problem and in this tutorial, we will demonstrate just that - we\u2019ll create a library with two functions; the first one will make sure that we can automatically set  ",Object(i.b)("inlineCode",{parentName:"p"},"_created_at")," and ",Object(i.b)("inlineCode",{parentName:"p"},"_updated_at"),"  timestamps for hash keys and the second one will simply update the ",Object(i.b)("inlineCode",{parentName:"p"},"_updated_at")," timestamp without changing the other elements, simulating the \u201ctouch\u201d Unix function. Let's go!"),Object(i.b)("h3",{id:"environment-setup"},"Environment setup"),Object(i.b)("p",null,"First, let\u2019s set up a working environment with Redis 7. You can follow the installation instructions in the guides below, according to your operating system:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://redis.io/docs/getting-started/installation/install-redis-from-source/"}),"Install Redis from Source")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://redis.io/docs/getting-started/installation/install-redis-on-linux/"}),"Install Redis on Linux")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://redis.io/docs/getting-started/installation/install-redis-on-mac-os/"}),"Install Redis on macOS")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(a.a)({parentName:"li"},{href:"https://redis.io/docs/getting-started/installation/install-redis-on-windows/"}),"Install Redis on Windows"))),Object(i.b)("p",null,"Alternatively, you can  spin up a Docker container with Redis Stack:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"$ docker run -p 6379:6379 --name redis-7.0 -it --rm redis/redis-stack:7.0.0-RC4\n")),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"Note: In the rest of this tutorial we\u2019ll use the ",Object(i.b)("inlineCode",{parentName:"p"},"$")," character to indicate that the command needs to be run on the command prompt and ",Object(i.b)("inlineCode",{parentName:"p"},"redis-cli>")," to indicate the same for a redis-cli prompt._")),Object(i.b)("h3",{id:"warm-up"},"Warm-Up"),Object(i.b)("p",null,"Now that we have our Redis server running, we can create a file named ",Object(i.b)("inlineCode",{parentName:"p"},"mylib.lua")," and in it create a function named ",Object(i.b)("inlineCode",{parentName:"p"},"hset")," that would receive the keys and arguments we pass on the command line as parameters. "),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},Object(i.b)("em",{parentName:"strong"},"Functions in Redis are always a part of a library, and a single library can have multiple functions. "))),Object(i.b)("p",null,'For starters, let\'s create a simple function that returns "Hello Redis 7.0" and save it in the ',Object(i.b)("inlineCode",{parentName:"p"},"mylib.lua")," file. "),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'#!lua name=mylib\n\nlocal function hset(keys, args)\n   return "Hello Redis 7.0"\nend\n')),Object(i.b)("p",null,"The first line specifies that we want to use the Lua engine to run this function and that its name is ",Object(i.b)("inlineCode",{parentName:"p"},"mylib"),".The name is the library identifier and we will use it every time we need to update it."),Object(i.b)("p",null,"Next, we need to register this function so it can be accessed through the Functions api. In the registration we specify that the function ",Object(i.b)("inlineCode",{parentName:"p"},"hset")," can be called with the name of ",Object(i.b)("inlineCode",{parentName:"p"},"my_hset"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"redis.register_function('my_hset', hset)\n")),Object(i.b)("p",null,"The full code, so far, is:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"#!lua name=mylib\nlocal function hset(keys, args)\n   return \"Hello Redis 7.0\"\nend\n\nredis.register_function('my_hset', hset)\n")),Object(i.b)("p",null,"Before we can call the function on the command line, we need to load and register it with the Redis server:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"$ cat /path/to/mylib.lua | redis-cli -x FUNCTION LOAD\n")),Object(i.b)("p",null,"Finally, let\u2019s run the function we registered:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"redis-cli> FCALL my_hset 1 foo\n")),Object(i.b)("p",null,'You should see the greeting "Hello Redis 7.0" as a response.'),Object(i.b)("h3",{id:"maintaining-a-consistent-view-of-data-entities-through-a-logical-schema"},"Maintaining a consistent view of data entities through a logical schema"),Object(i.b)("p",null,"We're now ready to start working on the requirement. First, let's implement the part that adds an ",Object(i.b)("code",null,Object(i.b)("em",null,Object(i.b)("em",{parentName:"p"},"updated")),"at"),"  timestamp:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"#!lua name=mylib\nlocal function hset(keys, args)\n   local hash = keys[1]  -- Get the key name\n   local time = redis.call('TIME')[1]  -- Get the current time from the Redis server\n\n   -- Add the current timestamp to the arguments that the user passed to the function, stored in `args`\n   table.insert(args, '_updated_at') \n   table.insert(args, time)\n\n   -- Run HSET with the updated argument list\n   return redis.call('HSET', hash, unpack(args))\nend\n\nredis.register_function('my_hset', hset)\n")),Object(i.b)("p",null,"After you updated the code, you will have to reload the library in the Redis server, using the ",Object(i.b)("inlineCode",{parentName:"p"},"replace")," argument to specify that you want to overwrite the previous version:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"$ cat /path/to/mylib.lua | redis-cli -x FUNCTION LOAD REPLACE\n")),Object(i.b)("p",null,"If you try to create and update a hash through our function now, you will see that a timestamp is automatically added to it:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'redis-cli> FCALL my_hset 1 foo k1 v1 k2 v2\n3\n\nredis-cli> HGETALL foo\n1) "k1"\n2) "v1"\n3) "k2"\n4) "v2"\n5) "_updated_at"\n6) "1643581494"\n')),Object(i.b)("p",null,"If we try to update the same key, we will see that the ",Object(i.b)("inlineCode",{parentName:"p"},"_updated_at")," timestamp got updated too:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'redis-cli> FCALL my_hset 1 foo k4 v4\n1\n\nredis-cli> HGETALL foo\n1) "k1"\n2) "v1"\n3) "k2"\n4) "v2"\n5) "_updated_at"\n6) "1643581580"\n7) "k4"\n8) "v4"\n')),Object(i.b)("p",null,"Now let's add the logic that checks if the key is being created or updated, and adds the ",Object(i.b)("inlineCode",{parentName:"p"},"_created_at")," timestamp accordingly:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"#!lua name=mylib\nlocal function hset(keys, args)\n   local hash = keys[1]  -- Get the key name\n   local time = redis.call('TIME')[1]  -- Get the current time from the Redis server\n\n   -- Check if the key exists and if not - add a `_created_at` timestamp\n   local exists = redis.call('exists', hash)\n   if exists==0 then\n       table.insert(args, '_created_at')\n       table.insert(args, time)\n   end\n\n   -- Add the current timestamp to the arguments that the user passed to the function, stored in `args`\n   table.insert(args, '_updated_at') \n   table.insert(args, time)\n\n   -- Run HSET with the updated argument list\n   return redis.call('HSET', hash, unpack(args))\nend\n\nredis.register_function('my_hset', hset)\n")),Object(i.b)("p",null,"Reload the library:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"$ cat /path/to/mylib.lua | redis-cli -x FUNCTION LOAD REPLACE\n")),Object(i.b)("p",null,"And try to create a new key:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'redis-cli> FCALL my_hset 1 bar k1 v1 k2 v2\n4\n\nredis-cli> HGETALL bar\n1) "k1"\n2) "v1"\n3) "k2"\n4) "v2"\n5) "_updated_at"\n6) "1643581710"\n7) "_created_at"\n8) "1643581710"\n')),Object(i.b)("p",null,"Both a ",Object(i.b)("inlineCode",{parentName:"p"},"_created_at")," and ",Object(i.b)("inlineCode",{parentName:"p"},"_updated_at")," timestamps were added. If we update the key, we will see that the ",Object(i.b)("inlineCode",{parentName:"p"},"_updated_at")," timestamp will change, while the ",Object(i.b)("inlineCode",{parentName:"p"},"_created_at")," will stay the same:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'redis-cli> FCALL my_hset 1 bar k4 v4\n1\n\nredis-cli> HMGET bar _created_at _updated_at\n1) "1643581710"\n2) "1643581992"\n')),Object(i.b)("p",null,"The second requirement was to implement a function that will allow us to update the ",Object(i.b)("inlineCode",{parentName:"p"},"_updated_at")," timestamp without updating any other fields. For that, we'll have to create a new function in our library:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"local function touch(keys, args)\n   local time = redis.call('TIME')[1]\n   return redis.call('HSET', keys[1], '_updated_at', time)\nend\n")),Object(i.b)("p",null,"And we should also add the function registration:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"redis.register_function('my_touch', touch)\n")),Object(i.b)("p",null,"The full code will now look like this:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"#!lua name=mylib\nlocal function hset(keys, args)\n   local hash = keys[1]  -- Get the key name\n   local time = redis.call('TIME')[1]  -- Get the current time from the Redis server\n\n   local exists = redis.call('exists', hash)\n   if exists==0 then\n       table.insert(args, '_created_at')\n       table.insert(args, time)\n   end\n\n   -- Add the current timestamp to the arguments that the user passed to the function, stored in `args`\n   table.insert(args, '_updated_at') \n   table.insert(args, time)\n\n   -- Run HSET with the updated argument list\n   return redis.call('HSET', hash, unpack(args))\nend\n\nlocal function touch(keys, args)\n   local time = redis.call('TIME')[1]\n   return redis.call('HSET', keys[1], '_updated_at', time)\nend   \n\nredis.register_function('my_hset', hset)\nredis.register_function('my_touch', touch)\n")),Object(i.b)("p",null,"Reload the updated library:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"$ cat /path/to/mylib.lua | redis-cli -x FUNCTION LOAD REPLACE\n")),Object(i.b)("p",null,"And try running the new function and confirm that the ",Object(i.b)("inlineCode",{parentName:"p"},"_updated_at")," timestamp has indeed changed:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'redis-cli> FCALL my_touch 1 bar\n0\n\nredis-cli> HMGET bar _created_at _updated_at\n1) "1643581710"\n2) "1643582276"\n')),Object(i.b)("h3",{id:"thinking-ahead"},"Thinking ahead"),Object(i.b)("p",null,"One of the basic rules of software development is that you cannot rely on user input, so let\u2019s make sure we don\u2019t do that. If a user creates a string named ",Object(i.b)("inlineCode",{parentName:"p"},"my_string")," and tries to run the touch function on it they will get an error:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"redis-cli> SET my_string hello\nOK\n\nredis-cli> FCALL my_hset 1 my_string k1 v1\n(error) WRONGTYPE Operation against a key holding the wrong kind of value script: my_hset, on @user_function:17.\n")),Object(i.b)("p",null,"Let\u2019s handle this error by adding a type check:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"if exists==1 and redis.call('TYPE', hash)[\"ok\"] ~= 'hash' then\n   error = 'The key ' .. hash .. ' is not a hash'\n   redis.log(redis.LOG_WARNING, error);\n   return redis.error_reply(error)\nend\n")),Object(i.b)("p",null,"The complete code:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"#!lua name=mylib\nlocal function hset(keys, args)\n   local hash = keys[1]  -- Get the key name\n   local time = redis.call('TIME')[1]  -- Get the current time from the Redis server\n\n   local exists = redis.call('exists', hash)\n   if exists==0 then\n       table.insert(args, '_created_at')\n       table.insert(args, time)\n   end\n\n   if exists==1 and redis.call('TYPE', hash)[\"ok\"] ~= 'hash' then\n       local error = 'The key ' .. hash .. ' is not a hash'\n       redis.log(redis.LOG_WARNING, error);\n       return redis.error_reply(error)\n   end\n\n   -- Add the current timestamp to the arguments that the user passed to the function, stored in `args`\n   table.insert(args, '_updated_at') \n   table.insert(args, time)\n\n   -- Run HSET with the updated argument list\n   return redis.call('HSET', hash, unpack(args))\nend\n\nlocal function touch(keys, args)\n   local time = redis.call('TIME')[1]\n   return redis.call('HSET', keys[1], '_updated_at', time)\nend   \n\nredis.register_function('my_hset', hset)\nredis.register_function('my_touch', touch)\n")),Object(i.b)("p",null,"If we reload the library and try again, we'll get an error with a helpful message:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"$ cat /path/to/mylib.lua | redis-cli -x FUNCTION LOAD REPLACE\n\nredis-cli> FCALL my_hset 1 my_string\n(error) The key my_string is not a hash\n")),Object(i.b)("h3",{id:"refactoring"},"Refactoring"),Object(i.b)("p",null,"We can notice that we have some code repetition in our library, namely the type check and the getting of the timestamp in both our functions. That's a good opportunity for some code reuse. Let's extract the logic into their own functions:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"local function get_time()\n     return redis.call('TIME')[1]\nend\n\nlocal function is_not_hash(key_name)\n   if redis.call('TYPE', key_name)['ok'] ~= 'hash' then\n       return 'The key ' .. key_name .. ' is not a hash.'\n   end\n\n   return nil\nend\n")),Object(i.b)("p",null,"This function is only going to be called by our two existing functions and not from the outside, so that's why we don't need to register it. The refactored code will now look like this:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"#!lua name=mylib\n\n-- Get the current time from the Redis server\nlocal function get_time()\n     return redis.call('TIME')[1]\nend\n\nlocal function is_not_hash(key_name)\n   if redis.call('TYPE', key_name)['ok'] ~= 'hash' then\n       return 'The key ' .. key_name .. ' is not a hash.'\n   end\n\n   return nil\nend\n\nlocal function hset(keys, args)\n   local hash = keys[1]  -- Get the key name\n   local time = get_time()\n\n   local exists = redis.call('exists', hash)\n   if exists==0 then\n       table.insert(args, '_created_at')\n       table.insert(args, time)\n   end\n\n   local hash_error = is_not_hash(hash)\n   if exists==1 and hash_error ~= nil then\n       return redis.error_reply(hash_error)\n   end\n\n   -- Add the current timestamp to the arguments that the user passed to the function, stored in `args`\n   table.insert(args, '_updated_at') \n   table.insert(args, time)\n\n   -- Run HSET with the updated argument list\n   return redis.call('HSET', hash, unpack(args))\nend\n\nlocal function touch(keys, args)\n   local hash = keys[1]\n\n   local hash_error = is_not_hash(hash)\n   if hash_error ~= nil then\n       return redis.error_reply(hash_error)\n   end\n\n   return redis.call('HSET', hash, '_updated_at', get_time())\nend   \n\nredis.register_function('my_hset', hset)\nredis.register_function('my_touch', touch)\n")),Object(i.b)("h3",{id:"using-function-flags"},"Using Function flags"),Object(i.b)("p",null,"In this step, we'll get familiar with the use of ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://redis.io/docs/manual/programmability/functions-intro/#function-flags"}),"Function flags")," - a piece of information that describes the circumstances under which a function is allowed to run. Currently, we support 5 flags:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"no-writes")," - this flag indicates that the script only reads data but never writes."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"allow-oom")," - this flag allows a script to execute even when the server is out of memory (OOM)."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"allow-stale")," - this flag enables running the script against a stale replica."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"no-cluster")," - this flag doesn't allow the script to run in a clustered database."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"allow-cross-slot-keys")," - this flag allows a script to access keys from multiple slots.")),Object(i.b)("p",null,"To best illustrate why function flags are useful we'll work with a simple example that gets the basic info and favourite colours of a user. Save the following snippet in a file named ",Object(i.b)("inlineCode",{parentName:"p"},"get_user.lua"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"#!lua name=mynewlib\nlocal function get_user(keys, args)\n   local hash = keys[1]  -- Get the key name\n\n   local user = redis.call('HGETALL', hash)\n   local user_colours = redis.call('SMEMBERS', hash .. ':colours')\n\n   table.insert(user, #user+1, 'colours')\n   table.insert(user, #user+1, user_colours)\n\n\n   return user\nend\n\nredis.register_function('get_user', get_user)\n")),Object(i.b)("p",null,"If we try to execute this function with ",Object(i.b)("inlineCode",{parentName:"p"},"FCALL_RO")," - the read-only variant of ",Object(i.b)("inlineCode",{parentName:"p"},"FCALL"),", we will get an error, even though it only performs read operations. In order to demonstrate that the function is read-only, we need to use the ",Object(i.b)("inlineCode",{parentName:"p"},"no-writes")," flag in its registration:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"$ cat /path/to/get_user.lua | redis-cli -x FUNCTION LOAD\n\nredis-cli> FCALL_RO get_user 1 user:1\n(error) ERR Can not execute a script with write flag using *_ro command.\n\n#!lua name=mynewlib\n\nlocal function get_user(keys, args)\n   local hash = keys[1]  -- Get the key name\n\n   local user = redis.call('HGETALL', hash)\n   local user_colours = redis.call('SMEMBERS', hash .. ':colours')\n\n   table.insert(user, #user+1, 'colours')\n   table.insert(user, #user+1, user_colours)\n\n\n   return user\nend\n\nredis.register_function{\n function_name='get_user',\n callback=get_user,\n flags={ 'no-writes' }\n}\n")),Object(i.b)("p",null,"Finally, this will give us the expected result:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'$ cat /path/to/get_user.lua | redis-cli -x FUNCTION LOAD REPLACE\n\nredis-cli> FCALL_RO get_user 1 user:1\n1) "email"\n2) "foo@bar.com"\n3) "colours"\n4) 1) "green"\n  2) "red"\n  3) "blue"\n')),Object(i.b)("p",null,"That's it, you now know how to write, load and execute Redis Function. Congratulations!"),Object(i.b)("p",null,"For more information on Redis Functions you can check the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://redis.io/docs/manual/programmability/functions-intro/"}),"Redis Functions documentation")," and to learn more about the Lua API you can check the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://redis.io/docs/manual/programmability/lua-api/"}),"Redis Lua API Reference"),"."))}d.isMDXComponent=!0},364:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return p}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=r.a.createContext({}),d=function(e){var t=r.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=d(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},h=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=d(n),h=a,p=u["".concat(s,".").concat(h)]||u[h]||b[h]||i;return n?r.a.createElement(p,l(l({ref:t},c),{},{components:n})):r.a.createElement(p,l({ref:t},c))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=h;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:a,s[1]=l;for(var c=2;c<i;c++)s[c]=n[c];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);