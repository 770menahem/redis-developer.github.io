"use strict";(self.webpackChunkredis_developer_hub=self.webpackChunkredis_developer_hub||[]).push([[1743],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>m});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=d(a),m=r,h=c["".concat(l,".").concat(m)]||c[m]||p[m]||s;return a?n.createElement(h,i(i({ref:t},u),{},{components:a})):n.createElement(h,i({ref:t},u))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,i=new Array(s);i[0]=c;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var d=2;d<s;d++)i[d]=a[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},13659:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>d});var n=a(87462),r=(a(67294),a(3905));const s={id:"stream-basics",title:"How to use Redis Streams with .NET",sidebar_label:"Using Redis Streams with .NET",slug:"/develop/dotnet/streams/stream-basics",authors:["steve"]},i=void 0,o={unversionedId:"develop/dotnet/streams/stream-basics",id:"develop/dotnet/streams/stream-basics",title:"How to use Redis Streams with .NET",description:"Redis Streams are a powerful data structure that allows you to use Redis as a sort of Message bus to transport messages between different application components. The way streams operate in Redis is very fast and memory efficient. This article will not go over the minutia of every command available for Redis Streams, but rather it's aimed to provide a high-level tutorial for how you can use Redis Streams with .NET.",source:"@site/docs/develop/dotnet/streams/streams-basics.md",sourceDirName:"develop/dotnet/streams",slug:"/develop/dotnet/streams/stream-basics",permalink:"/develop/dotnet/streams/stream-basics",draft:!1,editUrl:"https://github.com/redis-developer/redis-developer/edit/master/docs/develop/dotnet/streams/streams-basics.md",tags:[],version:"current",lastUpdatedAt:1667851300,formattedLastUpdatedAt:"Nov 7, 2022",frontMatter:{id:"stream-basics",title:"How to use Redis Streams with .NET",sidebar_label:"Using Redis Streams with .NET",slug:"/develop/dotnet/streams/stream-basics",authors:["steve"]},sidebar:"docs",previous:{title:"Grouping and Reductions",permalink:"/develop/dotnet/redis-om-dotnet/aggregations/groups/groups"},next:{title:"Blocking Stream Reads",permalink:"/develop/dotnet/streams/blocking-reads"}},l={},d=[{value:"Start Redis",id:"start-redis",level:2},{value:"Create your .NET app",id:"create-your-net-app",level:2},{value:"Add StackExchange.Redis package",id:"add-stackexchangeredis-package",level:2},{value:"Initialize the Multiplexer",id:"initialize-the-multiplexer",level:2},{value:"Create the consumer group",id:"create-the-consumer-group",level:2},{value:"Spin up producer task",id:"spin-up-producer-task",level:2},{value:"Parser helper function for reading results",id:"parser-helper-function-for-reading-results",level:2},{value:"Spin up most recent element task",id:"spin-up-most-recent-element-task",level:2},{value:"Spin up consumer group read Task",id:"spin-up-consumer-group-read-task",level:2},{value:"Set timeout and await tasks",id:"set-timeout-and-await-tasks",level:2},{value:"Run the app",id:"run-the-app",level:2},{value:"Resources:",id:"resources",level:2}],u={toc:d};function p(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Redis Streams are a powerful data structure that allows you to use Redis as a sort of Message bus to transport messages between different application components. The way streams operate in Redis is very fast and memory efficient. This article will not go over the minutia of every command available for Redis Streams, but rather it's aimed to provide a high-level tutorial for how you can use Redis Streams with .NET."),(0,r.kt)("h2",{id:"start-redis"},"Start Redis"),(0,r.kt)("p",null,"The first thing we'll want to do is start Redis. If you already have an instance of Redis, you can ignore this bit and adjust the connection step below to connect to your instance of Redis. Redis is straightforward to get up and running; you can do so using docker:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"docker run -p 6379:6379 redis\n")),(0,r.kt)("h2",{id:"create-your-net-app"},"Create your .NET app"),(0,r.kt)("p",null,"For simplicity's sake, we'll stick to a simple console app, from which we'll spin out a few tasks that will perform the various add/read operations that we'll use. Create a new console app with the ",(0,r.kt)("inlineCode",{parentName:"p"},"dotnet new")," command:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"dotnet new console -n RedisStreamsBasics\n")),(0,r.kt)("h2",{id:"add-stackexchangeredis-package"},"Add StackExchange.Redis package"),(0,r.kt)("p",null,"Next, we'll need to add the client library that we will use to interface with Redis StackExchange.Redis is the canonical package, thus, we will use that in this example. First cd into the RedisStreamsBasics directory and then run the ",(0,r.kt)("inlineCode",{parentName:"p"},"dotnet add package")," directory:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cd RedisStreamsBasics\ndotnet add package StackExchange.Redis\n")),(0,r.kt)("h2",{id:"initialize-the-multiplexer"},"Initialize the Multiplexer"),(0,r.kt)("p",null,"StackExchange.Redis centers more or less around the ",(0,r.kt)("inlineCode",{parentName:"p"},"ConnectionMultiplexer"),", which handles the routing and queuing of all commands that you send to Redis. So our first step that's code-related is to initialize the Multiplexer. Creating the Multiplexer is pretty straightforward; open up ",(0,r.kt)("inlineCode",{parentName:"p"},"Program.cs")," in your IDE and add the following bit to it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'using StackExchange.Redis;\n\nvar tokenSource = new CancellationTokenSource();\nvar token = tokenSource.Token;\n\nvar muxer = ConnectionMultiplexer.Connect("localhost");\nvar db = muxer.GetDatabase();\n\nconst string streamName = "telemetry";\nconst string groupName = "avg";\n')),(0,r.kt)("p",null,"We're also initializing a ",(0,r.kt)("inlineCode",{parentName:"p"},"CancellationToken")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"CancellationTokenSource")," here. We'll set these up towards the end of this tutorial so that this application does not run endlessly. Also, we're creating a couple of constants, the stream's name and the group's name, that we'll use later, and we are also grabbing an ",(0,r.kt)("inlineCode",{parentName:"p"},"IDatabase")," object from the Multiplexer to use"),(0,r.kt)("h2",{id:"create-the-consumer-group"},"Create the consumer group"),(0,r.kt)("p",null,"A Consumer Group in a Redis Stream allows you to group a bunch of consumers to pull messages off the stream for the group. This functionality is excellent when you have high throughput workloads, and you want to scale out the workers who will process your messages. To use a consumer group, you first need to create it. To create a consumer group, you'll use the ",(0,r.kt)("inlineCode",{parentName:"p"},"StreamCreateConsumerGroupAsync")," method, passing in the ",(0,r.kt)("inlineCode",{parentName:"p"},"streamName")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"groupName"),", as well as the starting id - we'll use the ",(0,r.kt)("inlineCode",{parentName:"p"},"0-0")," id (the lowest id allowable in Redis Streams). Before invoking this call, it's wise to validate that the group doesn't exist yet, as creating an already existing user group will result in an error. So first, we'll check if the stream exists; if it doesn't, we can create the group. Next, we'll use the stream info method to see if any groups match the ",(0,r.kt)("inlineCode",{parentName:"p"},"avg")," ",(0,r.kt)("inlineCode",{parentName:"p"},"groupName"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'if (!(await db.KeyExistsAsync(streamName)) ||\n    (await db.StreamGroupInfoAsync(streamName)).All(x=>x.Name!=groupName))\n{\n    await db.StreamCreateConsumerGroupAsync(streamName, groupName, "0-0", true);\n}\n')),(0,r.kt)("h2",{id:"spin-up-producer-task"},"Spin up producer task"),(0,r.kt)("p",null,"Three tasks will run in parallel for our program. The first is the ",(0,r.kt)("inlineCode",{parentName:"p"},"producerTask"),". This Task will write a random number between 50 and 65 as the ",(0,r.kt)("inlineCode",{parentName:"p"},"temp")," and send the current time as the ",(0,r.kt)("inlineCode",{parentName:"p"},"time"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'var producerTask = Task.Run(async () =>\n{\n    var random = new Random();\n    while (!token.IsCancellationRequested)\n    {\n        await db.StreamAddAsync(streamName,\n            new NameValueEntry[]\n                {new("temp", random.Next(50, 65)), new NameValueEntry("time", DateTimeOffset.Now.ToUnixTimeSeconds())});\n        await Task.Delay(2000);\n    }\n});\n')),(0,r.kt)("h2",{id:"parser-helper-function-for-reading-results"},"Parser helper function for reading results"),(0,r.kt)("p",null,"The results retrieved from Redis will be in a reasonably readable form; all the same, it is helpful for our purposes to parse the result into a dictionary. To do this, add an inline function to handle the parsing:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"Dictionary<string, string> ParseResult(StreamEntry entry) => entry.Values.ToDictionary(x => x.Name.ToString(), x => x.Value.ToString());\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Stream messages enforce no requirement that field names be unique. We use a dictionary for clarity sake in this example, but you will need to ensure that you are not passing in multiple fields with the same names in your usage to prevent an issue using a dictionary.")),(0,r.kt)("h2",{id:"spin-up-most-recent-element-task"},"Spin up most recent element task"),(0,r.kt)("p",null,"Next, we'll need to spin up a task to read the most recent element off of the stream. To do this, we'll use the ",(0,r.kt)("inlineCode",{parentName:"p"},"StreamRangeAsync")," method passing in two special ids, ",(0,r.kt)("inlineCode",{parentName:"p"},"-")," which means the lowest id, and ",(0,r.kt)("inlineCode",{parentName:"p"},"+"),", which means the highest id. Running this command will result in some duplication. This redundancy is necessary because the ",(0,r.kt)("inlineCode",{parentName:"p"},"StackExchange.Redis")," library does not support blocking stream reads and does not support the special ",(0,r.kt)("inlineCode",{parentName:"p"},"$")," character for stream reads. Overcoming this behavior is explored in-depth in the ",(0,r.kt)("a",{parentName:"p",href:"blocking-reads"},"Blocking Reads")," tutorial. For this tutorial, you can manage these most-recent reads with the following code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'var readTask = Task.Run(async () =>\n{\n    while (!token.IsCancellationRequested)\n    {\n        var result = await db.StreamRangeAsync(streamName, "-", "+", 1, Order.Descending);\n        if (result.Any())\n        {\n            var dict = ParseResult(result.First());\n            Console.WriteLine($"Read result: temp {dict["temp"]} time: {dict["time"]}");\n        }\n\n        await Task.Delay(1000);\n    }\n});\n')),(0,r.kt)("h2",{id:"spin-up-consumer-group-read-task"},"Spin up consumer group read Task"),(0,r.kt)("p",null,"The final Task we'll spin up is the read task for the consumer group. Due to the nature of consumer groups, you can spin this Task up multiple times to scale out the processing as needed. It's the responsibility of Redis to keep track of which messages it's distributed to the consumer group. As well as tracking which messages Consumers have acknowledged. Acknowledging messages adds a layer of validation that all messages were processed. If something happens to one of your processing tasks or processes, you can more easily know what messages you missed."),(0,r.kt)("p",null,"We'll check to see if we have a recent message-id to handle all of this. If we do, we will send an acknowledgment to the server that the id was processed. Then we will grab the next message to be processed from the stream, pull out the data and the id and print out the result."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'double count = default;\ndouble total = default;\n\nvar consumerGroupReadTask = Task.Run(async () =>\n{\n    string id = string.Empty;\n    while (!token.IsCancellationRequested)\n    {\n        if (!string.IsNullOrEmpty(id))\n        {\n            await db.StreamAcknowledgeAsync(streamName, groupName, id);\n            id = string.Empty;\n        }\n        var result = await db.StreamReadGroupAsync(streamName, groupName, "avg-1", ">", 1);\n        if (result.Any())\n        {\n            id = result.First().Id;\n            count++;\n            var dict = ParseResult(result.First());\n            total += double.Parse(dict["temp"]);\n            Console.WriteLine($"Group read result: temp: {dict["temp"]}, time: {dict["time"]}, current average: {total/count:00.00}");\n        }\n        await Task.Delay(1000);\n    }\n});\n')),(0,r.kt)("h2",{id:"set-timeout-and-await-tasks"},"Set timeout and await tasks"),(0,r.kt)("p",null,"Finally, we need to set the timeout and await the tasks at the end of our program:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"tokenSource.CancelAfter(TimeSpan.FromSeconds(20));\nawait Task.WhenAll(producerTask, readTask, consumerGroupReadTask);\n")),(0,r.kt)("h2",{id:"run-the-app"},"Run the app"),(0,r.kt)("p",null,"You can now run this app with the ",(0,r.kt)("inlineCode",{parentName:"p"},"dotnet run")," command."),(0,r.kt)("h2",{id:"resources"},"Resources:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The source for this tutorial is in ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/redis-developer/redis-streams-with-dotnet/tree/main/RedisStreamsStackExchange"},"GitHub")),(0,r.kt)("li",{parentName:"ul"},"Redis University has an extensive ",(0,r.kt)("a",{parentName:"li",href:"https://university.redis.com/courses/ru202/"},"course")," on Redis Streams where you can learn everything you need to know about them."),(0,r.kt)("li",{parentName:"ul"},"You can learn more about Redis Streams in the ",(0,r.kt)("a",{parentName:"li",href:"https://redis.io/topics/streams-intro"},"Streams Info")," article on redis.io")))}p.isMDXComponent=!0}}]);