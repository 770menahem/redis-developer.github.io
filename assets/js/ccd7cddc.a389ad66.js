"use strict";(self.webpackChunkredis_developer_hub=self.webpackChunkredis_developer_hub||[]).push([[250,7297,9570],{3905:(e,t,r)=>{r.d(t,{Zo:()=>l,kt:()=>m});var n=r(67294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var d=n.createContext({}),c=function(e){var t=n.useContext(d),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},l=function(e){var t=c(e.components);return n.createElement(d.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,d=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=c(r),m=o,h=u["".concat(d,".").concat(m)]||u[m]||p[m]||a;return r?n.createElement(h,i(i({ref:t},l),{},{components:r})):n.createElement(h,i({ref:t},l))}));function m(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=u;var s={};for(var d in t)hasOwnProperty.call(t,d)&&(s[d]=t[d]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}u.displayName="MDXCreateElement"},50358:(e,t,r)=>{r.d(t,{Z:()=>d});var n=r(67294),o=r(52263);const a="authorByline_VoxI",i="authorLabel_a70t",s="authorProfileImage_URwT";const d=function(e){let{frontMatter:t}=e;const{siteConfig:r}=(0,o.Z)(),d=r.customFields.authors;return n.createElement(n.Fragment,null,t.authors&&n.createElement("div",{className:"docAuthors"},n.createElement("hr",null),t.authors.map((e=>n.createElement("div",{key:e,className:a},n.createElement("img",{className:s,src:`/img/${d[e].image?d[e].image:"default_author_profile_pic.png"}`,alt:`Profile picture for ${d[e].name}`}),n.createElement("div",null,n.createElement("div",{className:i},"Author:"),n.createElement("div",null,n.createElement("a",{href:d[e].link,target:"_blank"},d[e].name),", ",d[e].title))))),n.createElement("hr",null)))}},38658:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var n=r(87462),o=(r(67294),r(3905));const a={},i=void 0,s={unversionedId:"howtos/solutions/common-data/microservices-arch",id:"howtos/solutions/common-data/microservices-arch",title:"microservices-arch",description:"You eventually land on the following architecture:",source:"@site/docs/howtos/solutions/common-data/microservices-arch.mdx",sourceDirName:"howtos/solutions/common-data",slug:"/howtos/solutions/common-data/microservices-arch",permalink:"/howtos/solutions/common-data/microservices-arch",draft:!1,editUrl:"https://github.com/redis-developer/redis-developer/edit/master/docs/howtos/solutions/common-data/microservices-arch.mdx",tags:[],version:"current",lastUpdatedAt:1678094580,formattedLastUpdatedAt:"Mar 6, 2023",frontMatter:{}},d={},c=[],l={toc:c};function p(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},l,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"You eventually land on the following architecture:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"products service")," - handles querying products from the database and returning them to the frontend"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"orders service")," - handles validating and creating orders"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"order history service")," - handles querying a customer's order history"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"payments service")," - handles processing orders for payment"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"api gateway")," - unifies your services under a single endpoint"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"mongodb")," - serves as the primary database, storing orders, order history, products, etc.")),(0,o.kt)("p",null,"Here is what the architecture diagram looks like so far:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Initial CQRS architecture",src:r(56922).Z,width:"2369",height:"998"})))}p.isMDXComponent=!0},95995:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var n=r(87462),o=(r(67294),r(3905));const a={},i=void 0,s={unversionedId:"howtos/solutions/common-data/microservices-ecommerce",id:"howtos/solutions/common-data/microservices-ecommerce",title:"microservices-ecommerce",description:"Consider below screenshots of sample e-commerce application",source:"@site/docs/howtos/solutions/common-data/microservices-ecommerce.mdx",sourceDirName:"howtos/solutions/common-data",slug:"/howtos/solutions/common-data/microservices-ecommerce",permalink:"/howtos/solutions/common-data/microservices-ecommerce",draft:!1,editUrl:"https://github.com/redis-developer/redis-developer/edit/master/docs/howtos/solutions/common-data/microservices-ecommerce.mdx",tags:[],version:"current",lastUpdatedAt:1678094580,formattedLastUpdatedAt:"Mar 6, 2023",frontMatter:{}},d={},c=[],l={toc:c};function p(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},l,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Consider below screenshots of sample e-commerce application"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Dashboard screen : To populate list of products with quick search functionality"),(0,o.kt)("p",{parentName:"li"},(0,o.kt)("img",{alt:"dashboard ",src:r(98920).Z,width:"2475",height:"1873"}))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Shopping Cart view : To view added products in the cart\n",(0,o.kt)("img",{alt:"cart",src:r(53296).Z,width:"2772",height:"1942"}))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Order history view : On ",(0,o.kt)("inlineCode",{parentName:"p"},"Orders")," tab click in the top nav bar, you can see all the orders for the user"),(0,o.kt)("p",{parentName:"li"},(0,o.kt)("img",{alt:"order history",src:r(28125).Z,width:"2511",height:"1351"})))),(0,o.kt)("p",null,"You can find the full source code for the app pictured above here. The frontend is build using ",(0,o.kt)("strong",{parentName:"p"},"Next.js"),", the backend is in ",(0,o.kt)("strong",{parentName:"p"},"Node.js"),", data is stored in ",(0,o.kt)("strong",{parentName:"p"},"MongoDB")," and ",(0,o.kt)("strong",{parentName:"p"},"Redis"),"."),(0,o.kt)("admonition",{title:"GITHUB CODE",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Source code for the application"),(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("a",{parentName:"p",href:"https://github.com/redis-developer/redis-microservices-ecommerce-solutions"},"https://github.com/redis-developer/redis-microservices-ecommerce-solutions"))))}p.isMDXComponent=!0},90011:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>g,frontMatter:()=>c,metadata:()=>p,toc:()=>m});var n=r(87462),o=(r(67294),r(3905)),a=r(50358),i=r(95995),s=r(38658);const d=r.p+"assets/images/cqrs-pattern-a00563de78207c32192c7e5c90ed38b8.png",c={id:"index-solutions-cqrs",title:"How to build an e-commerce app using Redis with the CQRS Pattern",sidebar_label:"How to build an e-commerce app using Redis with the CQRS Pattern",slug:"/howtos/solutions/cqrs",authors:["prasan","will"]},l=void 0,p={unversionedId:"howtos/solutions/cqrs/index-solutions-cqrs",id:"howtos/solutions/cqrs/index-solutions-cqrs",title:"How to build an e-commerce app using Redis with the CQRS Pattern",description:"Source code for the application used in this tutorial",source:"@site/docs/howtos/solutions/cqrs/index-cqrs.mdx",sourceDirName:"howtos/solutions/cqrs",slug:"/howtos/solutions/cqrs",permalink:"/howtos/solutions/cqrs",draft:!1,editUrl:"https://github.com/redis-developer/redis-developer/edit/master/docs/howtos/solutions/cqrs/index-cqrs.mdx",tags:[],version:"current",lastUpdatedAt:1678094580,formattedLastUpdatedAt:"Mar 6, 2023",frontMatter:{id:"index-solutions-cqrs",title:"How to build an e-commerce app using Redis with the CQRS Pattern",sidebar_label:"How to build an e-commerce app using Redis with the CQRS Pattern",slug:"/howtos/solutions/cqrs",authors:["prasan","will"]}},u={},m=[{value:"CQRS",id:"cqrs",level:2},{value:"Why you might use CQRS",id:"why-you-might-use-cqrs",level:2},{value:"Ecommerce (event-driven) architecture",id:"ecommerce-event-driven-architecture",level:2},{value:"Using CQRS in an event-driven architecture",id:"using-cqrs-in-an-event-driven-architecture",level:2},{value:"Ecommerce product",id:"ecommerce-product",level:2},{value:"Sample CQRS application with Redis and MongoDB",id:"sample-cqrs-application-with-redis-and-mongodb",level:2},{value:"Create Order API",id:"create-order-api",level:3},{value:"Create Order Request",id:"create-order-request",level:4},{value:"Create Order Response",id:"create-order-response",level:4},{value:"Order History API",id:"order-history-api",level:3},{value:"Order History Request",id:"order-history-request",level:4},{value:"Order History Response",id:"order-history-response",level:4},{value:"Conclusion",id:"conclusion",level:2},{value:"Additional Resources",id:"additional-resources",level:3}],h={toc:m};function g(e){let{components:t,...l}=e;return(0,o.kt)("wrapper",(0,n.Z)({},h,l,{components:t,mdxType:"MDXLayout"}),(0,o.kt)(a.Z,{frontMatter:c,mdxType:"Authors"}),(0,o.kt)("admonition",{title:"GITHUB CODE",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Source code for the application used in this tutorial"),(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("a",{parentName:"p",href:"https://github.com/redis-developer/redis-microservices-ecommerce-solutions"},"https://github.com/redis-developer/redis-microservices-ecommerce-solutions"))),(0,o.kt)("h2",{id:"cqrs"},"CQRS"),(0,o.kt)("p",null,'Command and Query Responsibility Segregation (CQRS) is a common pattern used in event-driven applications in-part to allow for scaling read and write workloads independently. The idea is simple: you separate commands such as "Order this product" (update operation) from queries such as "Show me my order history" (write operation). CQRS applications are often messaging-based and rely on eventual consistency.'),(0,o.kt)("img",{src:d,alt:"CQRS pattern",width:"500"}),(0,o.kt)("h2",{id:"why-you-might-use-cqrs"},"Why you might use CQRS"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("em",{parentName:"p"},"To improve application performance, scale your read and write operations separately."))),(0,o.kt)("p",null,'Consider the following scenario. You have an e-commerce application that allows a customer to populate a shopping cart with products, and has a "Buy Now" button to facilitate ordering the products. When you first start out, you might setup a primary database like MongoDB and populate it with products. Then you might write a backend API to handle creating the order, creating an invoice, processing payment, handling fulfillment, and updating the customer\'s order history all in one go.'),(0,o.kt)("p",null,"This method of synchronous order processing seems like a good idea, but you quickly find out that your database slows down as you gain more customers and have a higher sales volume. You decide that you need to ",(0,o.kt)("strong",{parentName:"p"},"process orders")," quickly so the customer doesn't have to wait. Then, when you have time you can create an invoice, process payment, handle fulfillment, etc. So you decide to separate each of these steps and use an event-driven approach with CQRS to allow you to scale your reads and writes separately."),(0,o.kt)("h2",{id:"ecommerce-event-driven-architecture"},"Ecommerce (event-driven) architecture"),(0,o.kt)(s.default,{mdxType:"InitialMicroservicesArchitecture"}),(0,o.kt)("h2",{id:"using-cqrs-in-an-event-driven-architecture"},"Using CQRS in an event-driven architecture"),(0,o.kt)("p",null,"However, note that in the current architecture all the services use the same underlying database. Even though we are technically separating reads and writes, we can't scale our database independently. This is where Redis comes in. If we put Redis in front of our primary database, we can use it for reads while writing to the primary database. The benefit of Redis is that it is fast for reads and writes, which is why it is the defacto choice for caching. Our architecture now might look like the following:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"CQRS architecture with Redis",src:r(8886).Z,width:"2340",height:"1013"})),(0,o.kt)("p",null,"What is not depicted in the images above is the events happening to coordinate communication between the services. This is covered in the ",(0,o.kt)("a",{parentName:"p",href:"/howtos/solutions/interservice-communication"},"interservice communication guide"),". For now, let's look at some sample code that helps facilitate the CQRS pattern with Redis and MongoDB."),(0,o.kt)("h2",{id:"ecommerce-product"},"Ecommerce product"),(0,o.kt)(i.default,{mdxType:"MicroservicesEcommerceDesign"}),(0,o.kt)("h2",{id:"sample-cqrs-application-with-redis-and-mongodb"},"Sample CQRS application with Redis and MongoDB"),(0,o.kt)("p",null,"Let's consider sample code for ",(0,o.kt)("inlineCode",{parentName:"p"},"order service")," to see the ",(0,o.kt)("inlineCode",{parentName:"p"},"CreateOrder")," API (a write operation) and 'order history service' to see the ",(0,o.kt)("inlineCode",{parentName:"p"},"viewOrderHistory")," API (a read operation)"),(0,o.kt)("h3",{id:"create-order-api"},"Create Order API"),(0,o.kt)("p",null,"Below you will find an example API request and response to create an order."),(0,o.kt)("h4",{id:"create-order-request"},"Create Order Request"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'// POST http://api-gateway/orders/createOrder\n{\n  "products": [\n    {\n      "productId": 11000,\n      "qty": 2,\n      "productPrice": 3995\n    },\n    {\n      "productId": 11001,\n      "qty": 1,\n      "productPrice": 5450\n    }\n  ]\n}\n')),(0,o.kt)("h4",{id:"create-order-response"},"Create Order Response"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "data": "63f5f8dc3696d145a45775a6", // orderId\n  "error": null\n}\n')),(0,o.kt)("p",null,"When you make a request, it goes through the API gateway to the ",(0,o.kt)("inlineCode",{parentName:"p"},"orders service"),". Ultimately it ends up calling a ",(0,o.kt)("inlineCode",{parentName:"p"},"createOrder")," function which looks as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"async function createOrder(order: IOrder) {\n  if (!order) {\n    throw 'Order data is mandatory!';\n  }\n\n  order.orderStatusCode = ORDER_STATUS.CREATED;\n  order.userId = USERS.DEFAULT; // Used as a shortcut, in a real app you would use customer session data to fetch user details\n  order.createdOn = new Date();\n  order.createdBy = order.userId;\n  order.lastUpdatedOn = null;\n  order.lastUpdatedBy = null;\n  order.statusCode = DB_ROW_STATUS.ACTIVE;\n\n  order = await validateOrder(order);\n\n  const orderId = await addOrderToRedis(order);\n  order.orderId = orderId;\n\n  await addOrderToMongoDB(order);\n\n  return orderId;\n}\n")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"For simplicity, we are adding data to both MongoDB & Redis in same service. Instead we can add data to any one store and use synchronization technique to sync with other.\nFor eg: You might consider using ",(0,o.kt)("strong",{parentName:"p"},"RedisGears")," to handle sync between Redis and mongodb in the background."),(0,o.kt)("p",{parentName:"admonition"},"For the purposes of this tutorial we are not going to outline exactly how you might do synchronization, but instead focus on how the data is stored and accessed in Redis.")),(0,o.kt)("p",null,"Note above that we are calling the ",(0,o.kt)("inlineCode",{parentName:"p"},"addOrderToRedis")," function to store our orders in Redis. Below is what that function looks like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="server/src/services/orders"',title:'"server/src/services/orders"'},"import { Entity, Schema } from 'redis-om';\nimport { getRedisOmClient } from '../utils/redis/redis-wrapper';\n\nclass OrderEntity extends Entity {}\n\nconst schema = new Schema(OrderEntity, {\n  orderId: { type: 'string' },\n  userId: { type: 'string' },\n  orderStatusCode: { type: 'number' },\n\n  productsStr: { type: 'string' },\n\n  createdOn: { type: 'date' },\n  createdBy: { type: 'string' },\n  lastUpdatedOn: { type: 'date' },\n  lastUpdatedBy: { type: 'string' },\n  statusCode: { type: 'number' },\n});\n\nasync function addOrderToRedis(order: IOrder) {\n  let orderId = '';\n\n  const redisOmClient = getRedisOmClient();\n  const repository = redisOmClient.fetchRepository(schema);\n  const entity = repository.createEntity(order);\n\n  orderId = entity.entityId;\n  entity.orderId = orderId;\n\n  await repository.save(entity);\n\n  return orderId;\n}\n")),(0,o.kt)("p",null,"We're using Redis OM for Node.js to store the order entities in Redis."),(0,o.kt)("h3",{id:"order-history-api"},"Order History API"),(0,o.kt)("p",null,"Below you will find an example API request and response to get a customer's order history."),(0,o.kt)("h4",{id:"order-history-request"},"Order History Request"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},"// GET http://api-gateway/orderHistory/viewOrderHistory\n")),(0,o.kt)("h4",{id:"order-history-response"},"Order History Response"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "data": [\n    {\n      "orderId": "01GTH7JTQWP5QSEY32NNKT6B88",\n      "userId": "ADMIN",\n      "orderStatusCode": 1,\n      "products": [\n        {\n          "productId": 11000,\n          "qty": 10,\n          "productPrice": 3995,\n          "productData": {\n            "id": 11000,\n            "price": 3995,\n            "productDisplayName": "Puma Men Slick 3HD Yellow Black Watches",\n            "variantName": "Slick 3HD Yellow",\n            "brandName": "Puma",\n            "ageGroup": "Adults-Men",\n            "gender": "Men",\n            "displayCategories": "Accessories",\n            "styleImages": {\n              "default": {\n                "imageURL": "http://cdn_service/images/11000.jpg"\n              }\n            },\n            "productDescriptors": {\n              "description": {\n                "value": "Stylish and comfortable, this motor sport inspired wrist watch from puma is designed with a plastic case and ..."\n              }\n            }\n          }\n        },\n        {\n          "productId": 11001,\n          "qty": 19,\n          "productPrice": 5450,\n          "productData": {\n            "id": 11001,\n            "price": 5450,\n            "productDisplayName": "Puma Men Top Fluctuation Red Black Watches",\n            "variantName": "Top Fluctuation Red",\n            "brandName": "Puma",\n            "ageGroup": "Adults-Men",\n            "gender": "Men",\n            "displayCategories": "Accessories",\n            "styleImages": {\n              "default": {\n                "imageURL": "http://cdn_service/images/11001.jpg"\n              }\n            },\n            "productDescriptors": {\n              "description": {\n                "value": "This watch from puma comes in a clean sleek design. This active watch is perfect for urban wear and ..."\n              }\n            }\n          }\n        }\n      ],\n      "createdOn": "2023-03-02T13:18:31.657Z",\n      "createdBy": "ADMIN",\n      "lastUpdatedOn": null,\n      "lastUpdatedBy": null\n    }\n    //...\n  ],\n  "error": null\n}\n')),(0,o.kt)("p",null,"When you make a request, it goes through the API gateway to the ",(0,o.kt)("inlineCode",{parentName:"p"},"order history service"),". Ultimately it ends up calling a ",(0,o.kt)("inlineCode",{parentName:"p"},"viewOrderHistory")," function which looks as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="server/src/services/order-history"',title:'"server/src/services/order-history"'},"async function viewOrderHistory(userId: string) {\n  const repository = OrderRepo.getRepository();\n  let orders: IOrder[] = [];\n\n  const result = repository\n    .search()\n    .where('createdBy')\n    .eq(userId)\n    .and('orderStatusCode')\n    .gte(ORDER_STATUS.CREATED) //gte returns CREATED and PAYMENT_SUCCESS\n    .and('statusCode')\n    .eq(DB_ROW_STATUS.ACTIVE)\n    .return.all();\n\n  orders = result.map((elm) => {\n    return {\n      orderId: elm.orderId,\n      userId: elm.userId,\n      orderStatusCode: elm.orderStatusCode,\n      createdOn: elm.createdOn,\n      createdBy: elm.createdBy,\n      lastUpdatedOn: elm.lastUpdatedOn,\n      lastUpdatedBy: elm.lastUpdatedBy,\n    } as IOrder;\n  });\n\n  return orders;\n}\n")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Note that the ",(0,o.kt)("inlineCode",{parentName:"p"},"order history service")," only needs to go to Redis for all orders. This is because we are handling storing and synchronizing between Redis and MongoDB within the ",(0,o.kt)("inlineCode",{parentName:"p"},"orders service"),".")),(0,o.kt)("p",null,"You might be used to using Redis as a cache and both storing and retrieving stringified JSON values or perhaps hashed values. However, if you look closely at the code above we are storing orders as JSON documents, and then using Redis OM to search for the orders belonging to a specific user. So in reality Redis is operating like a database and providing the ability to speed up queries and scale independently from the primary database (MongoDB in this case)."),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"Hopefully this tutorial has helped you visualize how you might use Redis with the CQRS pattern to help reduce the load on your primary database while still allowing you to store and search JSON documents. See below for some additional resources around this topic."),(0,o.kt)("h3",{id:"additional-resources"},"Additional Resources"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/howtos/solutions/interservice-communication"},"Interservice communication")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/howtos/solutions/caching"},"Query caching")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/howtos/solutions/api-gateway-caching"},"API gateway caching"))))}g.isMDXComponent=!0},53296:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/design-cart-2-53bcfc9de6293c66337d1a1d7a80dab5.png"},98920:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/design-dashboard-face10f3332e9a77b8b427dc4cfb18fd.png"},28125:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/design-order-history-15153e22828baa23b0269a711f3aac5b.png"},56922:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/initial-microservices-arch-c9628e81ef3c808f33d0cd6a2557f4cf.png"},8886:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/cqrs-architecture-with-redis-6517401dadf02e0d44d16ebff788ff5c.png"}}]);