"use strict";(self.webpackChunkredis_developer_hub=self.webpackChunkredis_developer_hub||[]).push([[2201],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>m});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),d=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},p=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=d(r),m=a,h=u["".concat(l,".").concat(m)]||u[m]||c[m]||i;return r?n.createElement(h,o(o({ref:t},p),{},{components:r})):n.createElement(h,o({ref:t},p))}));function m(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var d=2;d<i;d++)o[d]=r[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}u.displayName="MDXCreateElement"},71409:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var n=r(87462),a=(r(67294),r(3905));const i={id:"cs-redis",title:"Blocking Stream reads with CSRedis",sidebar_label:"Blocking Stream Reads with CSRedis",slug:"/develop/dotnet/streams/blocking-reads/cs-redis",authors:["steve"]},o=void 0,s={unversionedId:"develop/dotnet/streams/blocking-reads/cs-redis/cs-redis",id:"develop/dotnet/streams/blocking-reads/cs-redis/cs-redis",title:"Blocking Stream reads with CSRedis",description:"CSRedis is an MIT Licensed Open source project which provides a straightforward interface for executing commands. CSRedis can be used effectively for performing blocking stream reads with the one major downside that it does not support any async API for them.",source:"@site/docs/develop/dotnet/streams/blocking-reads/cs-redis/cs-redis.md",sourceDirName:"develop/dotnet/streams/blocking-reads/cs-redis",slug:"/develop/dotnet/streams/blocking-reads/cs-redis",permalink:"/develop/dotnet/streams/blocking-reads/cs-redis",draft:!1,editUrl:"https://github.com/redis-developer/redis-developer/edit/master/docs/develop/dotnet/streams/blocking-reads/cs-redis/cs-redis.md",tags:[],version:"current",lastUpdatedAt:1655485542,formattedLastUpdatedAt:"Jun 17, 2022",frontMatter:{id:"cs-redis",title:"Blocking Stream reads with CSRedis",sidebar_label:"Blocking Stream Reads with CSRedis",slug:"/develop/dotnet/streams/blocking-reads/cs-redis",authors:["steve"]},sidebar:"docs",previous:{title:"Blocking Stream Reads with ServiceStack.Redis",permalink:"/develop/dotnet/streams/blocking-reads/service-stack"},next:{title:"Go",permalink:"/develop/golang/"}},l={},d=[{value:"Start Redis",id:"start-redis",level:2},{value:"Create the app",id:"create-the-app",level:2},{value:"Add the package to your app",id:"add-the-package-to-your-app",level:2},{value:"Create group",id:"create-group",level:2},{value:"Write to the stream",id:"write-to-the-stream",level:2},{value:"Parsing read results",id:"parsing-read-results",level:2},{value:"Blocking XREAD",id:"blocking-xread",level:2},{value:"Blocking XREADGROUP",id:"blocking-xreadgroup",level:2},{value:"Spin up threads",id:"spin-up-threads",level:2},{value:"Run the app",id:"run-the-app",level:2},{value:"Resources:",id:"resources",level:2}],p={toc:d};function c(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/2881099/csredis"},"CSRedis")," is an MIT Licensed Open source project which provides a straightforward interface for executing commands. CSRedis can be used effectively for performing blocking stream reads with the one major downside that it does not support any async API for them."),(0,a.kt)("h2",{id:"start-redis"},"Start Redis"),(0,a.kt)("p",null,"Before we begin, we'll start up Redis. If you are developing locally, which we'll assume you are for the duration of this tutorial, you can start Redis with a simple docker command."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"docker run -p 6379:6379 redis\n")),(0,a.kt)("h2",{id:"create-the-app"},"Create the app"),(0,a.kt)("p",null,"We will build a simple console application for streaming telemetry using the library. To do so, use the ",(0,a.kt)("inlineCode",{parentName:"p"},"dotnet new")," command:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"dotnet new console -n StreamsWithCSRedis\n")),(0,a.kt)("h2",{id:"add-the-package-to-your-app"},"Add the package to your app"),(0,a.kt)("p",null,"Run the ",(0,a.kt)("inlineCode",{parentName:"p"},"cd StreamsWithCSRedis")," command to change directories into the application's directory and run the following to add the CSRedis package"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"dotnet add package CSRedisCore\n")),(0,a.kt)("h2",{id:"create-group"},"Create group"),(0,a.kt)("p",null,"When we start up our app, the first thing we'll do is create our ",(0,a.kt)("inlineCode",{parentName:"p"},"avg")," group. To make this group, open up ",(0,a.kt)("inlineCode",{parentName:"p"},"Program.cs")," and add to it the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'var cancellationTokenSource = new CancellationTokenSource();\nvar token = cancellationTokenSource.Token;\n\nvar client = new CSRedisClient("localhost");\nif (!client.Exists("stream") || client.XInfoStream("stream").groups == 0)\n{\n    client.XGroupCreate("stream", "avg", "$", MkStream: true);\n}\n')),(0,a.kt)("p",null,"This code will create a cancellation token for the threads we'll spin up to do the writes/reads to the stream, create a client, check if our ",(0,a.kt)("inlineCode",{parentName:"p"},"avg")," group already exists, and finally create the ",(0,a.kt)("inlineCode",{parentName:"p"},"avg")," group if it doesn't."),(0,a.kt)("h2",{id:"write-to-the-stream"},"Write to the stream"),(0,a.kt)("p",null,"Next, we'll write out to the stream. We'll call the stream ",(0,a.kt)("inlineCode",{parentName:"p"},"stream"),", and send a ",(0,a.kt)("inlineCode",{parentName:"p"},"temp")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"time")," field along with the stream. We'll do this every 2 seconds. We'll put this on its own thread, since this operation isn't actually 'blocking' in the Redis sense, it may be alright to spin it out on its task, but as the other two operations in here are blocking, it's better to spin it off on its own thread as well. Add the following to your ",(0,a.kt)("inlineCode",{parentName:"p"},"Program.cs")," file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'var writeThread = new Thread(() =>\n{\n    var writeClient = new CSRedisClient("localhost");\n    var random = new Random();\n    while (!token.IsCancellationRequested)\n    {\n        writeClient.XAdd("stream", new (string, string)[]{new ("temp", random.Next(50,65).ToString()), new ("time", DateTimeOffset.Now.ToUnixTimeSeconds().ToString())});\n        Thread.Sleep(2000);\n    }\n});\n')),(0,a.kt)("h2",{id:"parsing-read-results"},"Parsing read results"),(0,a.kt)("p",null,"The next issue we'll need to dispose of is parsing the read results from the ",(0,a.kt)("inlineCode",{parentName:"p"},"XREAD")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"XREADGROUP")," commands. CSRedis handles return types generally as tuples in a reply, so we'll need a way to parse the result into something more useable. In this case, we'll parse the results into a dictionary. For the sake of brevity, we will keep everything in this project in ",(0,a.kt)("inlineCode",{parentName:"p"},"Program.cs")," on the top-level method, so we'll declare a ",(0,a.kt)("inlineCode",{parentName:"p"},"Func")," to handle the parsing. This function will pull the first message from the first stream and arrange the values returned into a dictionary. A couple of things to consider here if you wanted to expand this further is that you could reply with a dictionary of dictionaries if you were pulling back multiple messages from multiple streams. This complexity is intentionally left out."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"Func<(string key, (string id, string[] items)[] data), Dictionary<string,string>> parse = delegate((string key, (string id, string[] items)[] data) streamResult)\n{\n    var message = streamResult.data.First().items;\n    var result = new Dictionary<string, string>();\n    for (var i = 0; i < message.Length; i += 2)\n    {\n        result.Add(message[i], message[i+1]);\n    }\n\n    return result;\n};\n")),(0,a.kt)("h2",{id:"blocking-xread"},"Blocking XREAD"),(0,a.kt)("p",null,"There are two primary types of 'read' methods, ",(0,a.kt)("inlineCode",{parentName:"p"},"XREAD")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"XREADGROUP"),", this is in addition to the various range methods, which are their category and operate semantically differently from the read operations. ",(0,a.kt)("inlineCode",{parentName:"p"},"XREAD")," lets you read off a given stream and read the ",(0,a.kt)("em",{parentName:"p"},"next")," item that hit's the stream. You can do this with the special ",(0,a.kt)("inlineCode",{parentName:"p"},"$")," id. For our purposes here, we are going to block for two seconds, or whenever we get a response back from redis, whichever comes first:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'var readThread = new Thread(() =>\n{\n    var readClient = new CSRedisClient("localhost");\n    while (!token.IsCancellationRequested)\n    {\n        var result = readClient.XRead(1, 5000, new (string key, string id)[] {new("stream", "$")});\n        if (result != null)\n        {\n            var dictionary = parse(result[0]);\n            Console.WriteLine($"Most recent message, time: {dictionary["time"]} temp: {dictionary["temp"]}");\n        }\n    }\n});\n')),(0,a.kt)("h2",{id:"blocking-xreadgroup"},"Blocking XREADGROUP"),(0,a.kt)("p",null,"Blocking ",(0,a.kt)("inlineCode",{parentName:"p"},"XREADGROUP")," commands operate very similarly to ",(0,a.kt)("inlineCode",{parentName:"p"},"XREAD"),". In this case, however, the creation of the group told us what id to start at, and by passing in the ",(0,a.kt)("inlineCode",{parentName:"p"},">")," we necessarily start off at the next message in the queue. Because we are reading out of a group, we'll also want to ",(0,a.kt)("inlineCode",{parentName:"p"},"XACK")," to any messages that we pull down. Also, since this is our average group, we'll maintain an average for our stream's temperatures."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'var total = 0;\nvar count = 0;\nvar groupReadThread = new Thread(() =>\n{\n    var groupReadClient = new CSRedisClient("localhost");\n    var id = string.Empty;\n    while (!token.IsCancellationRequested)\n    {\n        if (!string.IsNullOrEmpty(id))\n        {\n            client.XAck("stream", "avg", id);\n        }\n        var result =\n            groupReadClient.XReadGroup("avg", "avg-1", 1, 5000, new (string key, string id)[] {new("stream", ">")});\n        if (result != null)\n        {\n            id = result.First().data.First().id;\n            var dictionary = parse(result[0]);\n            if (dictionary.ContainsKey("temp"))\n            {\n                count++;\n                total += int.Parse(dictionary["temp"]);\n                double avg = (double) total / count;\n                Console.WriteLine($"Most recent group message, time: {dictionary["time"]} temp: {dictionary["temp"]} avg: {avg:00.00}");\n            }\n        }\n    }\n});\n')),(0,a.kt)("h2",{id:"spin-up-threads"},"Spin up threads"),(0,a.kt)("p",null,"The last thing we'll need to do is start up all the threads, set a cancellation timeout (so the app doesn't run forever), and join all the threads back together:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"readThread.Start();\nwriteThread.Start();\ngroupReadThread.Start();\n\ncancellationTokenSource.CancelAfter(TimeSpan.FromSeconds(10));\n\nreadThread.Join();\nwriteThread.Join();\ngroupReadThread.Join();\n")),(0,a.kt)("h2",{id:"run-the-app"},"Run the app"),(0,a.kt)("p",null,"Now that the app is written, all that's left to do is run it. You can do so by running `dotnet run in your terminal."),(0,a.kt)("h2",{id:"resources"},"Resources:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The source for this tutorial is in ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/redis-developer/redis-streams-with-dotnet/tree/main/StreamsWithCSRedis"},"GitHub")),(0,a.kt)("li",{parentName:"ul"},"Redis University has an extensive ",(0,a.kt)("a",{parentName:"li",href:"https://university.redis.com/courses/ru202/"},"course")," on Redis Streams where you can learn everything you need to know about them."),(0,a.kt)("li",{parentName:"ul"},"You can learn more about Redis Streams in the ",(0,a.kt)("a",{parentName:"li",href:"https://redis.io/topics/streams-intro"},"Streams Info")," article on redis.io")))}c.isMDXComponent=!0}}]);