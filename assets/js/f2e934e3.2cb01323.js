"use strict";(self.webpackChunkredis_developer_hub=self.webpackChunkredis_developer_hub||[]).push([[3049,1144,9570],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>p});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),d=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=d(e.components);return r.createElement(c.Provider,{value:t},e.children)},l={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,c=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),u=d(n),p=a,h=u["".concat(c,".").concat(p)]||u[p]||l[p]||s;return n?r.createElement(h,o(o({ref:t},m),{},{components:n})):r.createElement(h,o({ref:t},m))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,o=new Array(s);o[0]=u;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var d=2;d<s;d++)o[d]=n[d];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},50358:(e,t,n)=>{n.d(t,{Z:()=>c});var r=n(67294),a=n(52263);const s="authorByline_VoxI",o="authorLabel_a70t",i="authorProfileImage_URwT";const c=function(e){let{frontMatter:t}=e;const{siteConfig:n}=(0,a.Z)(),c=n.customFields.authors;return r.createElement(r.Fragment,null,t.authors&&r.createElement("div",{className:"docAuthors"},r.createElement("hr",null),t.authors.map((e=>r.createElement("div",{key:e,className:s},r.createElement("img",{className:i,src:`/img/${c[e].image?c[e].image:"default_author_profile_pic.png"}`,alt:`Profile picture for ${c[e].name}`}),r.createElement("div",null,r.createElement("div",{className:o},"Author:"),r.createElement("div",null,r.createElement("a",{href:c[e].link,target:"_blank"},c[e].name),", ",c[e].title))))),r.createElement("hr",null)))}},30989:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>s,metadata:()=>i,toc:()=>d});var r=n(87462),a=(n(67294),n(3905));const s={},o=void 0,i={unversionedId:"howtos/solutions/common-data/microservices-arch-with-redis",id:"howtos/solutions/common-data/microservices-arch-with-redis",title:"microservices-arch-with-redis",description:"Thinking about the e-commerce application, consider the following architecture:",source:"@site/docs/howtos/solutions/common-data/microservices-arch-with-redis.mdx",sourceDirName:"howtos/solutions/common-data",slug:"/howtos/solutions/common-data/microservices-arch-with-redis",permalink:"/howtos/solutions/common-data/microservices-arch-with-redis",draft:!1,editUrl:"https://github.com/redis-developer/redis-developer/edit/master/docs/howtos/solutions/common-data/microservices-arch-with-redis.mdx",tags:[],version:"current",lastUpdatedAt:1678094580,formattedLastUpdatedAt:"Mar 6, 2023",frontMatter:{}},c={},d=[],m={toc:d};function l(e){let{components:t,...s}=e;return(0,a.kt)("wrapper",(0,r.Z)({},m,s,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Thinking about the e-commerce application, consider the following architecture:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"products service")," - handles querying products from the database and returning them to the frontend"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"orders service")," - handles validating and creating orders"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"order history service")," - handles querying a customer's order history"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"payments service")," - handles processing orders for payment"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"api gateway")," - unifies your services under a single endpoint"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"mongodb")," - serves as the primary database, storing orders, order history, products, etc."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"redis")," - serves as the stream processor and caching database")),(0,a.kt)("p",null,"Here is what the architecture diagram looks like so far:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Microservices architecture with Redis",src:n(87251).Z,width:"2340",height:"1013"})),(0,a.kt)("p",null,"What's nice about this architecture is each service is setup so it can scale independently. What this also means is you can incrementally adopt Redis where needed."))}l.isMDXComponent=!0},95995:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>s,metadata:()=>i,toc:()=>d});var r=n(87462),a=(n(67294),n(3905));const s={},o=void 0,i={unversionedId:"howtos/solutions/common-data/microservices-ecommerce",id:"howtos/solutions/common-data/microservices-ecommerce",title:"microservices-ecommerce",description:"Consider below screenshots of sample e-commerce application",source:"@site/docs/howtos/solutions/common-data/microservices-ecommerce.mdx",sourceDirName:"howtos/solutions/common-data",slug:"/howtos/solutions/common-data/microservices-ecommerce",permalink:"/howtos/solutions/common-data/microservices-ecommerce",draft:!1,editUrl:"https://github.com/redis-developer/redis-developer/edit/master/docs/howtos/solutions/common-data/microservices-ecommerce.mdx",tags:[],version:"current",lastUpdatedAt:1678094580,formattedLastUpdatedAt:"Mar 6, 2023",frontMatter:{}},c={},d=[],m={toc:d};function l(e){let{components:t,...s}=e;return(0,a.kt)("wrapper",(0,r.Z)({},m,s,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Consider below screenshots of sample e-commerce application"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Dashboard screen : To populate list of products with quick search functionality"),(0,a.kt)("p",{parentName:"li"},(0,a.kt)("img",{alt:"dashboard ",src:n(98920).Z,width:"2475",height:"1873"}))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Shopping Cart view : To view added products in the cart\n",(0,a.kt)("img",{alt:"cart",src:n(53296).Z,width:"2772",height:"1942"}))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Order history view : On ",(0,a.kt)("inlineCode",{parentName:"p"},"Orders")," tab click in the top nav bar, you can see all the orders for the user"),(0,a.kt)("p",{parentName:"li"},(0,a.kt)("img",{alt:"order history",src:n(28125).Z,width:"2511",height:"1351"})))),(0,a.kt)("p",null,"You can find the full source code for the app pictured above here. The frontend is build using ",(0,a.kt)("strong",{parentName:"p"},"Next.js"),", the backend is in ",(0,a.kt)("strong",{parentName:"p"},"Node.js"),", data is stored in ",(0,a.kt)("strong",{parentName:"p"},"MongoDB")," and ",(0,a.kt)("strong",{parentName:"p"},"Redis"),"."),(0,a.kt)("admonition",{title:"GITHUB CODE",type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Source code for the application"),(0,a.kt)("p",{parentName:"admonition"},(0,a.kt)("a",{parentName:"p",href:"https://github.com/redis-developer/redis-microservices-ecommerce-solutions"},"https://github.com/redis-developer/redis-microservices-ecommerce-solutions"))))}l.isMDXComponent=!0},27035:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>c,metadata:()=>m,toc:()=>u});var r=n(87462),a=(n(67294),n(3905)),s=n(50358),o=n(95995),i=n(30989);const c={id:"index-solutions-interservice-communication",title:"Microservices Communication with Redis streams",sidebar_label:"Microservices Communication with Redis streams",slug:"/howtos/solutions/interservice-communication",authors:["prasan","will"]},d=void 0,m={unversionedId:"howtos/solutions/interservice-communication/index-solutions-interservice-communication",id:"howtos/solutions/interservice-communication/index-solutions-interservice-communication",title:"Microservices Communication with Redis streams",description:"Source code for the application used in this tutorial",source:"@site/docs/howtos/solutions/interservice-communication/index-interservice-communication.mdx",sourceDirName:"howtos/solutions/interservice-communication",slug:"/howtos/solutions/interservice-communication",permalink:"/howtos/solutions/interservice-communication",draft:!1,editUrl:"https://github.com/redis-developer/redis-developer/edit/master/docs/howtos/solutions/interservice-communication/index-interservice-communication.mdx",tags:[],version:"current",lastUpdatedAt:1678094580,formattedLastUpdatedAt:"Mar 6, 2023",frontMatter:{id:"index-solutions-interservice-communication",title:"Microservices Communication with Redis streams",sidebar_label:"Microservices Communication with Redis streams",slug:"/howtos/solutions/interservice-communication",authors:["prasan","will"]}},l={},u=[{value:"Interservice Communication",id:"interservice-communication",level:2},{value:"Why you should use Redis for Interservice Communication",id:"why-you-should-use-redis-for-interservice-communication",level:2},{value:"Ecommerce micro services architecture",id:"ecommerce-micro-services-architecture",level:2},{value:"Using Redis for Interservice Communication in an Event-driven Architecture",id:"using-redis-for-interservice-communication-in-an-event-driven-architecture",level:2},{value:"Ecommerce product",id:"ecommerce-product",level:2},{value:"Sample Interservice Communication Application with Redis and MongoDB",id:"sample-interservice-communication-application-with-redis-and-mongodb",level:2},{value:"Producer 1 (Orders Service)",id:"producer-1-orders-service",level:3},{value:"consumer 1 (payments Service)",id:"consumer-1-payments-service",level:3},{value:"producer 2 (payments Service)",id:"producer-2-payments-service",level:3},{value:"consumer 2 (orders Service)",id:"consumer-2-orders-service",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Additional Resources",id:"additional-resources",level:3}],p={toc:u};function h(e){let{components:t,...d}=e;return(0,a.kt)("wrapper",(0,r.Z)({},p,d,{components:t,mdxType:"MDXLayout"}),(0,a.kt)(s.Z,{frontMatter:c,mdxType:"Authors"}),(0,a.kt)("admonition",{title:"GITHUB CODE",type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Source code for the application used in this tutorial"),(0,a.kt)("p",{parentName:"admonition"},(0,a.kt)("a",{parentName:"p",href:"https://github.com/redis-developer/redis-microservices-ecommerce-solutions"},"https://github.com/redis-developer/redis-microservices-ecommerce-solutions"))),(0,a.kt)("h2",{id:"interservice-communication"},"Interservice Communication"),(0,a.kt)("p",null,"When building a microservices application, people use different options for communication between services like"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Publish Subscribe")," model : In pub sub model (fire & forget model), publisher just produces the messages & ",(0,a.kt)("strong",{parentName:"li"},"active")," subscribers at that time can consume those messages. Subscribers which are down cannot receive the messages at later point of time."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Streams")," : Most people decide to use an event ",(0,a.kt)("strong",{parentName:"li"},"streaming")," solution because of")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Messages persistence")," : Unlike pub sub model, messages are stored in streams. So Subscriber can always read messages at later point of time even if it is down for a while.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Inherent re-playability")," : Even if subscriber crashes during the message processing, it can re-read exactly same unacknowledged message from stream. Say, crashed subscriber never came up - then consumer group feature allows consumers to process unacknowledged messages of other consumers after a specified time.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Separation of concerns")," : Producers can produce messages to stream at ",(0,a.kt)("strong",{parentName:"p"},"high speed"),' separately and consumers can process messages at their own speed separately. So separation of concerns solves both "fast producer -> slow consumer" or "slow producer -> fast consumer" problem by allowing to scale those services independently.'))),(0,a.kt)("p",null,"In an event-driven architecture you might have some services that publish an API, and other services that are simply producers and consumers of events with no external API."),(0,a.kt)("h2",{id:"why-you-should-use-redis-for-interservice-communication"},"Why you should use Redis for Interservice Communication"),(0,a.kt)("p",null,"Consider the following scenario."),(0,a.kt)("p",null,"You have an e-commerce application which is broken down in to different microservices like create an orders, create an invoice, process payment, handle fulfillment, etc. Microservices will allow each service to scale independently so now more customers can process their orders at less time simultaneously resulting in better user experience and higher sales volume."),(0,a.kt)("p",null,"When there are microservices, you obviously need some way of communication between them. You might initially consider using a product like ",(0,a.kt)("strong",{parentName:"p"},"Kafka")," for streaming, but the setup for it is rather complicated. What many people don't know about Redis is that it supports streams similar to Kafka. Given that you are likely to use Redis for caching already, it makes sense to also use it for stream processing. To reduce complexity of application architecture and maintenance, ",(0,a.kt)("strong",{parentName:"p"},"Redis")," is a great option for interservice communication. Keep reading for a break down of how to use Redis with streams for interservice communication."),(0,a.kt)("h2",{id:"ecommerce-micro-services-architecture"},"Ecommerce micro services architecture"),(0,a.kt)(i.default,{mdxType:"MicroservicesArchitectureWithRedis"}),(0,a.kt)("h2",{id:"using-redis-for-interservice-communication-in-an-event-driven-architecture"},"Using Redis for Interservice Communication in an Event-driven Architecture"),(0,a.kt)("p",null,"Below is an event flow diagram that outlines how the ",(0,a.kt)("inlineCode",{parentName:"p"},"orders")," & ",(0,a.kt)("inlineCode",{parentName:"p"},"payments")," services communicate through Redis with streams."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Microservices streaming with Redis event flow diagram",src:n(73903).Z,width:"1161",height:"1235"})),(0,a.kt)("p",null,"Let's outline the streams and events used below:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},'"orders service" inserts full "order" data to database'),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "orderId": "01GTP3K2TZQQCQ0T2G43DSSMTD",\n  "products": [\n    {\n      "productId": 11000,\n      "qty": 3,\n      "productPrice": 3995,\n      "productData": {\n        "productDisplayName": "Puma Men Slick 3HD Yellow Black Watches",\n        "variantName": "Slick 3HD Yellow",\n        "brandName": "Puma",\n        "ageGroup": "Adults-Men",\n        "gender": "Men"\n        //...\n      }\n    },\n    {\n      "productId": 11001,\n      "qty": 2,\n      "productPrice": 5450,\n      "productData": {\n        "productDisplayName": "Puma Men Top Fluctuation Red Black Watches",\n        "variantName": "Top Fluctuation Red",\n        "brandName": "Puma",\n        "ageGroup": "Adults-Men",\n        "gender": "Men"\n        //...\n      }\n    }\n  ],\n  "userId": "USR_4e7acc44-e91e-4c5c-9112-bdd99d799dd3",\n  "orderStatusCode": 1, //order created\n  "createdOn": {\n    "$date": {\n      "$numberLong": "1677926697801"\n    }\n  },\n  "createdBy": "USR_4e7acc44-e91e-4c5c-9112-bdd99d799dd3",\n  "statusCode": 1\n}\n'))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},'"orders service" also enters minimal data (orderId, orderAmount & userId) to ',(0,a.kt)("inlineCode",{parentName:"p"},"ORDERS_STREAM"),' to signal new order creation (acts as "PRODUCER" of "ORDERS_STREAM")'),(0,a.kt)("p",{parentName:"li"},(0,a.kt)("img",{alt:"orders-stream",src:n(30243).Z,width:"2432",height:"812"}))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},'"payments service" listens to ',(0,a.kt)("inlineCode",{parentName:"p"},"ORDERS_STREAM"),', process payment for new orderId and insert "payments" data to database (acts as "CONSUMER" of "ORDERS_STREAM")'),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "paymentId": "6403212956a976300afbaac1",\n  "orderId": "01GTP3K2TZQQCQ0T2G43DSSMTD",\n  "orderAmount": 22885,\n  "paidAmount": 22885,\n  "orderStatusCode": 3, //payment successful\n  "userId": "USR_4e7acc44-e91e-4c5c-9112-bdd99d799dd3",\n  "createdOn": {\n    "$date": {\n      "$numberLong": "1677926697841"\n    }\n  },\n  "createdBy": "USR_4e7acc44-e91e-4c5c-9112-bdd99d799dd3",\n  "statusCode": 1\n}\n'))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},'"payments service" also enters minimal data (orderId,paymentId, orderStatusCode & userId) to ',(0,a.kt)("inlineCode",{parentName:"p"},"PAYMENTS_STREAM"),' - to signal new payment fulfillment (acts as "PRODUCER" of "PAYMENTS_STREAM")\n',(0,a.kt)("img",{alt:"payments-stream",src:n(32517).Z,width:"2406",height:"688"}))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},'"orders service" now listens to ',(0,a.kt)("inlineCode",{parentName:"p"},"PAYMENTS_STREAM"),', updates orderStatus and paymentId in database accordingly for the order which has fulfilled payment (acts as "CONSUMER" of "PAYMENTS_STREAM")'))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  //order collection update\n  "orderId": "01GTP3K2TZQQCQ0T2G43DSSMTD",\n  "paymentId": "6403212956a976300afbaac1",\n  "orderStatusCode": 3 //payment success\n  //...\n}\n')),(0,a.kt)("h2",{id:"ecommerce-product"},"Ecommerce product"),(0,a.kt)(o.default,{mdxType:"MicroservicesEcommerceDesign"}),(0,a.kt)("h2",{id:"sample-interservice-communication-application-with-redis-and-mongodb"},"Sample Interservice Communication Application with Redis and MongoDB"),(0,a.kt)("p",null,"We're using Redis to broker the events sent between the orders service and the payments service."),(0,a.kt)("h3",{id:"producer-1-orders-service"},"Producer 1 (Orders Service)"),(0,a.kt)("p",null,"Let's look at some of the code in the orders service to understand how it works."),(0,a.kt)("p",null,'(step 1) After order creation , (step 2) "orders service" enters minimal data to ORDERS_STREAM to signal new order creation (acts as "PRODUCER" of "ORDERS_STREAM")'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const addOrderIdToStream = async (\n  orderId: string,\n  orderAmount: number,\n  userId: string,\n) => {\n  const nodeRedisClient = getNodeRedisClient();\n  if (orderId && nodeRedisClient) {\n    const streamKeyName = 'ORDERS_STREAM';\n    const entry = {\n      orderId: orderId,\n      orderAmount: orderAmount.toFixed(2),\n      userId: userId,\n    };\n    const id = '*'; //* = auto generate\n    //xAdd adds entry to specified stream\n    await nodeRedisClient.xAdd(streamKeyName, id, entry);\n  }\n};\n")),(0,a.kt)("h3",{id:"consumer-1-payments-service"},"consumer 1 (payments Service)"),(0,a.kt)("p",null,'(step 3)"payments service" listens to ',(0,a.kt)("inlineCode",{parentName:"p"},"ORDERS_STREAM"),' (acts as "CONSUMER" of "ORDERS_STREAM")'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"//Below is some code for how you would use Redis to listen for the stream events:\n\nasync function listenToStream(\n  onMessage: (message: any, messageId: string) => Promise<void>,\n) {\n  // using node-redis\n  const redis = getNodeRedisClient();\n  const streamKeyName = 'ORDERS_STREAM'; //stream name\n  const groupName = 'ORDERS_CON_GROUP'; //listening consumer group name (custom)\n  const consumerName = 'PAYMENTS_CON'; //listening consumer name (custom)\n  const readMaxCount = 100;\n\n  // Check if the stream group already exists\n  if (!(await redis.exists(streamKeyName))) {\n    const idPosition = '0'; //0 = start, $ = end or any specific id\n    await nodeRedisClient.xGroupCreate(streamKeyName, groupName, idPosition, {\n      MKSTREAM: true,\n    });\n  }\n\n  // setup a loop to listen for stream events\n  while (true) {\n    // read set of messages from different streams\n    const dataArr = await nodeRedisClient.xReadGroup(\n      commandOptions({\n        isolated: true,\n      }),\n      groupName,\n      consumerName,\n      [\n        {\n          // you can specify multiple streams in array\n          key: streamKeyName,\n          id: '>', // Next entry ID that no consumer in this group has read\n        },\n      ],\n      {\n        COUNT: readMaxCount, // Read n entries at a time\n        BLOCK: 0, // block for 0 (infinite) seconds if there are none.\n      },\n    );\n\n    for (let data of dataArr) {\n      for (let messageItem of data.messages) {\n        //process the message received (in our case, perform payment)\n        await onMessage(messageItem.message, messageItem.id);\n\n        // acknowledge individual messages after processing\n        nodeRedisClient.xAck(streamKeyName, groupName, messageItem.id);\n      }\n    }\n  }\n}\n\n//\"listenToStream\" listens for events and calls the `onMessage` callback to further handle the events.\nlistenToStream({\n  onMessage: processPaymentForNewOrders,\n});\n\nconst processPaymentForNewOrders: IMessageHandler = async (\n  message,\n  messageId,\n) => {\n  /*\n   message = {\n      orderId: \"\",\n      orderAmount: \"\",\n      userId: \"\",\n    }\n    */\n  //process payment for new orderId and insert \"payments\" data to database\n};\n")),(0,a.kt)("p",null,"There are a few important things to note here:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Make sure the stream group doesn't exist prior to creating it."),(0,a.kt)("li",{parentName:"ol"},"Use ",(0,a.kt)("inlineCode",{parentName:"li"},"isolated: true,")," in order to use the blocking version of ",(0,a.kt)("inlineCode",{parentName:"li"},"XREADGROUP")," in ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/redis/node-redis/blob/master/docs/isolated-execution.md"},"isolated execution")," mode."),(0,a.kt)("li",{parentName:"ol"},"Acknowledge individual messages after they have been processed to remove them from the queue (Pending entries list ) and avoid processing them more than once.")),(0,a.kt)("h3",{id:"producer-2-payments-service"},"producer 2 (payments Service)"),(0,a.kt)("p",null,'(step 4) "payments service" also enters minimal data to ',(0,a.kt)("inlineCode",{parentName:"p"},"PAYMENTS_STREAM"),' - to signal new payment fulfillment (acts as "PRODUCER" of "PAYMENTS_STREAM")'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const addPaymentIdToStream = async (\n  orderId: string,\n  paymentId: string,\n  orderStatus: number,\n  userId: string,\n) => {\n  const nodeRedisClient = getNodeRedisClient();\n  if (orderId && nodeRedisClient) {\n    const streamKeyName = 'PAYMENTS_STREAM';\n    const entry = {\n      orderId: orderId,\n      paymentId: paymentId,\n      orderStatusCode: orderStatus.toString(),\n      userId: userId,\n    };\n    const id = '*'; //* = auto generate\n    //xAdd adds entry to specified stream\n    await nodeRedisClient.xAdd(streamKeyName, id, entry);\n  }\n};\n")),(0,a.kt)("h3",{id:"consumer-2-orders-service"},"consumer 2 (orders Service)"),(0,a.kt)("p",null,'(step 5) "orders service" now listens to ',(0,a.kt)("inlineCode",{parentName:"p"},"PAYMENTS_STREAM"),' (acts as "CONSUMER" of "PAYMENTS_STREAM")'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"//Below is some code for how you would use Redis to listen for the stream events:\n\nasync function listenToStream(\n  onMessage: (message: any, messageId: string) => Promise<void>,\n) {\n  // using node-redis\n  const redis = getNodeRedisClient();\n  const streamKeyName = 'PAYMENTS_STREAM'; //stream name\n  const groupName = 'PAYMENTS_CON_GROUP'; //listening consumer group name (custom)\n  const consumerName = 'ORDERS_CON'; //listening consumer name (custom)\n  const readMaxCount = 100;\n\n  // Check if the stream group already exists\n  if (!(await redis.exists(streamKeyName))) {\n    const idPosition = '0'; //0 = start, $ = end or any specific id\n    await nodeRedisClient.xGroupCreate(streamKeyName, groupName, idPosition, {\n      MKSTREAM: true,\n    });\n  }\n\n  // setup a loop to listen for stream events\n  while (true) {\n    // read set of messages from different streams\n    const dataArr = await nodeRedisClient.xReadGroup(\n      commandOptions({\n        isolated: true,\n      }),\n      groupName,\n      consumerName,\n      [\n        {\n          // you can specify multiple streams in array\n          key: streamKeyName,\n          id: '>', // Next entry ID that no consumer in this group has read\n        },\n      ],\n      {\n        COUNT: readMaxCount, // Read n entries at a time\n        BLOCK: 0, // block for 0 (infinite) seconds if there are none.\n      },\n    );\n\n    for (let data of dataArr) {\n      for (let messageItem of data.messages) {\n        //process the message received (in our case, updateOrderStatus)\n        await onMessage(messageItem.message, messageItem.id);\n\n        // acknowledge individual messages after processing\n        nodeRedisClient.xAck(streamKeyName, groupName, messageItem.id);\n      }\n    }\n  }\n}\n\n//\"listenToStream\" listens for events and calls the `onMessage` callback to further handle the events.\nlistenToStream({\n  onMessage: updateOrderStatus,\n});\n\nconst updateOrderStatus: IMessageHandler = async (message, messageId) => {\n  /*\n   message = {\n      orderId: \"\",\n      paymentId: \"\",\n      orderStatusCode:\"\",\n      userId: \"\",\n    }\n    */\n  //updates orderStatus and paymentId in database accordingly for the order which has fulfilled payment\n  //updateOrderStatusInRedis(orderId,paymentId,orderStatusCode,userId)\n  //updateOrderStatusInMongoDB(orderId,paymentId,orderStatusCode,userId)\n};\n")),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"It's best practice to validate the incoming messages to make sure you can work with them.")),(0,a.kt)("p",null,"For the purposes of our application we are making a call to update the order status in Redis and MongoDB. An alternative option is to use something like RedisGears to synchronize the data between Redis and MongoDB. Doing so would allow you to simply write to Redis, which would then trigger RedisGears to subsequently write to MongoDB. It's a small difference, but many people choose to go this route because of the cleaner implementation and separation of concerns."),(0,a.kt)("h2",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"That's all there is to it! You've now seen how to use Redis for streaming as both a producer and a consumer. Hopefully you can draw some inspiration from this tutorial and apply it to your own event streaming application. See below for some additional resources around this topic."),(0,a.kt)("h3",{id:"additional-resources"},"Additional Resources"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Explore streams in detail in the ",(0,a.kt)("a",{parentName:"li",href:"https://university.redis.com/courses/ru202/"},"Redis University course on Redis Streams")),(0,a.kt)("li",{parentName:"ul"},"Check out our e-book on ",(0,a.kt)("a",{parentName:"li",href:"https://redis.com/docs/understanding-streams-in-redis-and-kafka-a-visual-guide/"},"Understanding Streams in Redis and Kafka \u2013 A Visual Guide")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/howtos/solutions/cqrs"},"CQRS")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/howtos/solutions/caching"},"Query caching")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/howtos/solutions/api-gateway-caching"},"API gateway caching"))))}h.isMDXComponent=!0},53296:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/design-cart-2-53bcfc9de6293c66337d1a1d7a80dab5.png"},98920:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/design-dashboard-face10f3332e9a77b8b427dc4cfb18fd.png"},28125:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/design-order-history-15153e22828baa23b0269a711f3aac5b.png"},87251:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/redis-microservices-arch-6a6896038f20517635bdfc18d32cc3db.png"},30243:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/02-orders-stream-6ea657d20ccd504410c9a4ac269c2d25.png"},32517:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/04-payments-stream-fe3a620a63ccf1a5ccd54f3d750b8ab9.png"},73903:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/interservice-communication-event-flow-diagram-f7f79635f6af9a76ee095fee644885cc.png"}}]);