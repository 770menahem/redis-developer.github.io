"use strict";(self.webpackChunkredis_developer_hub=self.webpackChunkredis_developer_hub||[]).push([[8997],{85162:(e,t,i)=>{i.d(t,{Z:()=>o});var n=i(67294),a=i(86010);const r="tabItem_Ymn6";function o(e){let{children:t,hidden:i,className:o}=e;return n.createElement("div",{role:"tabpanel",className:(0,a.Z)(r,o),hidden:i},t)}},65488:(e,t,i)=>{i.d(t,{Z:()=>c});var n=i(87462),a=i(67294),r=i(86010),o=i(72389),l=i(67392),s=i(7094),u=i(12466);const d="tabList__CuJ",m="tabItem_LNqP";function p(e){var t;const{lazy:i,block:o,defaultValue:p,values:c,groupId:h,className:w}=e,f=a.Children.map(e.children,(e=>{if((0,a.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),v=c??f.map((e=>{let{props:{value:t,label:i,attributes:n}}=e;return{value:t,label:i,attributes:n}})),g=(0,l.l)(v,((e,t)=>e.value===t.value));if(g.length>0)throw new Error(`Docusaurus error: Duplicate values "${g.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const k=null===p?p:p??(null==(t=f.find((e=>e.props.default)))?void 0:t.props.value)??f[0].props.value;if(null!==k&&!v.some((e=>e.value===k)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${k}" but none of its children has the corresponding value. Available values are: ${v.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:b,setTabGroupChoices:x}=(0,s.U)(),[N,y]=(0,a.useState)(k),E=[],{blockElementScrollPositionUntilNextRender:I}=(0,u.o5)();if(null!=h){const e=b[h];null!=e&&e!==N&&v.some((t=>t.value===e))&&y(e)}const q=e=>{const t=e.currentTarget,i=E.indexOf(t),n=v[i].value;n!==N&&(I(t),y(n),null!=h&&x(h,String(n)))},T=e=>{var t;let i=null;switch(e.key){case"Enter":q(e);break;case"ArrowRight":{const t=E.indexOf(e.currentTarget)+1;i=E[t]??E[0];break}case"ArrowLeft":{const t=E.indexOf(e.currentTarget)-1;i=E[t]??E[E.length-1];break}}null==(t=i)||t.focus()};return a.createElement("div",{className:(0,r.Z)("tabs-container",d)},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":o},w)},v.map((e=>{let{value:t,label:i,attributes:o}=e;return a.createElement("li",(0,n.Z)({role:"tab",tabIndex:N===t?0:-1,"aria-selected":N===t,key:t,ref:e=>E.push(e),onKeyDown:T,onClick:q},o,{className:(0,r.Z)("tabs__item",m,null==o?void 0:o.className,{"tabs__item--active":N===t})}),i??t)}))),i?(0,a.cloneElement)(f.filter((e=>e.props.value===N))[0],{className:"margin-top--md"}):a.createElement("div",{className:"margin-top--md"},f.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==N})))))}function c(e){const t=(0,o.Z)();return a.createElement(p,(0,n.Z)({key:String(t)},e))}},71131:(e,t,i)=>{i.d(t,{Z:()=>h});var n=i(67294),a=i(3905),r=i(52195);const o="riContainer_bco2",l="riDescriptionShort_E27B",s="riDetail_wzFs",u="riIcon_yDou",d="riTitle_x6vI",m="riDescription_RDnu",p="riMore_apRP";var c=i(86010);const h=e=>{const[t,i]=n.useState(!1);return n.createElement("a",{href:e.page,className:o},n.createElement("div",{className:l},n.createElement("div",{className:u},n.createElement("span",{className:"fe fe-zap"})),n.createElement("div",{className:s},n.createElement("div",{className:d},n.createElement("a",{href:e.page},e.title)),n.createElement("div",{className:m},e.description,n.Children.count(e.children)>0&&n.createElement("span",{className:(0,c.Z)(p,"fe","fe-more-horizontal"),onClick:()=>i(!t)})))),t&&n.createElement("div",{className:"ri-description-long"},n.createElement(a.Zo,{components:r.Z},e.children)))}},86381:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>u});var n=i(87462),a=(i(67294),i(3905));i(65488),i(85162),i(44996),i(71131);const r={id:"index-spring-fixed-window",title:"How to Implement Fixed Window Rate Limiting using Redis",sidebar_label:"Overview",slug:"/develop/java/spring/rate-limiting/fixed-window",authors:["bsb"]},o=void 0,l={unversionedId:"develop/java/spring/rate-limiting/fixed-window/index-spring-fixed-window",id:"develop/java/spring/rate-limiting/fixed-window/index-spring-fixed-window",title:"How to Implement Fixed Window Rate Limiting using Redis",description:'The simplest approach to build a rate limiter is the "fixed window" implementation in which we cap the',source:"@site/docs/develop/java/spring/rate-limiting/fixed-window/index-fixed-window.mdx",sourceDirName:"develop/java/spring/rate-limiting/fixed-window",slug:"/develop/java/spring/rate-limiting/fixed-window",permalink:"/develop/java/spring/rate-limiting/fixed-window",draft:!1,editUrl:"https://github.com/redis-developer/redis-developer/edit/master/docs/develop/java/spring/rate-limiting/fixed-window/index-fixed-window.mdx",tags:[],version:"current",lastUpdatedAt:1655485542,formattedLastUpdatedAt:"Jun 17, 2022",frontMatter:{id:"index-spring-fixed-window",title:"How to Implement Fixed Window Rate Limiting using Redis",sidebar_label:"Overview",slug:"/develop/java/spring/rate-limiting/fixed-window",authors:["bsb"]},sidebar:"docs",previous:{title:"Overview",permalink:"/develop/java/spring/rate-limiting"},next:{title:"Reactive Implementation",permalink:"/develop/java/spring/rate-limiting/fixed-window/reactive"}},s={},u=[],d={toc:u};function m(e){let{components:t,...i}=e;return(0,a.kt)("wrapper",(0,n.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,'The simplest approach to build a rate limiter is the "fixed window" implementation in which we cap the\nmaximum number of requests in a fixed window of time. For exmaple, if the window size is 1 hour, we can\n"fix" it at the top of the hour, like 12:00-12:59, 1:00-1:59, and so forth.'),(0,a.kt)("p",null,"The procedure to implement a fixed window rate limiter is fairly simple, for each request we:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Identify the requester"),": This might be an API key, a token, a user's name or id, or even an IP address."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Find the current window"),': Use the current time to find the window. Assume that we are working with 1 hour windows\nand it\'s 3:15 PM, we could use a 24 hour clock and label this window "15".'),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Find the request count"),': Find the fixed window request count for the requester. For example, say we\'ve\nidentified the requester to be user with id "u123", and it\'s 3:15 PM. We will look for a count under the\nkey "u123:15" where the value store under that key is the count of requests for user u123 from 3:00 PM\nto 3:59:59 PM.'),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Increment the request count"),": Increment the request count for the window+user key."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Rate Limit if applicable"),": If the count exceeds the user's quota, then deny the request, otherwise, allow the\nrequests to proceed.")),(0,a.kt)("p",null,'The fixed window recipe ignores the cost of the request (all requests are created equal) and in this particular implementation\nit uses a single quota for all all users. This simple implementation minimizes the CPU and I/O utilization but that comes with\nsome limitations. It is possible to experience spikes near the edges of the window, since APIs users might program their\nrequests in a "use or lose it" approach.'),(0,a.kt)("p",null,"One way to minimize the spikiness in this scheme is to have multiple time windows of different granularity. For example, you can\nrate limit at the hour and minute levels, say, allowing a maximum of 2,000 request per hour, and a maximum of 33 requests\nper minute."),(0,a.kt)("p",null,"This basic recipe using Redis Strings, a minute-size window and a quota of 20 requests is outlined on\nthe ",(0,a.kt)("a",{parentName:"p",href:"https://redis.com/redis-best-practices/basic-rate-limiting/"},"Redis Blog"),". I'll summarize it here before we jump\ninto out Spring Reactive implementation:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"GET [user-api-key]:[current minute number]")," such as ",(0,a.kt)("inlineCode",{parentName:"li"},'GET "u123:45"')),(0,a.kt)("li",{parentName:"ol"},"If the result from line 1 is less than 20 (or the key is not found) go to step 4 otherwise continue to step 3"),(0,a.kt)("li",{parentName:"ol"},"Reject the request."),(0,a.kt)("li",{parentName:"ol"},"In an atomic way (using ",(0,a.kt)("inlineCode",{parentName:"li"},"MULTI")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"EXEC"),") increment the key and set the expiry to 59 seconds into the future.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"MULTI\nINCR [user-api-key]:[current minute number]\nEXPIRE [user-api-key]:[current minute number] 59\nEXEC\n")),(0,a.kt)("ol",{start:5},(0,a.kt)("li",{parentName:"ol"},"Otherwise, fulfill the request.")),(0,a.kt)("p",null,"Ok, now that we know the basic recipe, let's implement it in ",(0,a.kt)("a",{parentName:"p",href:"/develop/java/spring/rate-limiting/fixed-window/reactive"},"Spring")))}m.isMDXComponent=!0}}]);