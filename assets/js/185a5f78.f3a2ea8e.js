"use strict";(self.webpackChunkredis_developer_hub=self.webpackChunkredis_developer_hub||[]).push([[141],{3905:function(e,t,a){a.d(t,{Zo:function(){return d},kt:function(){return m}});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},d=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=c(a),m=r,h=u["".concat(l,".").concat(m)]||u[m]||p[m]||i;return a?n.createElement(h,s(s({ref:t},d),{},{components:a})):n.createElement(h,s({ref:t},d))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var c=2;c<i;c++)s[c]=a[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},98243:function(e,t,a){a.r(t),a.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return p}});var n=a(87462),r=a(63366),i=(a(67294),a(3905)),s=["components"],o={id:"service-stack",title:"How to handle blocking stream reads with ServiceStack.Redis",sidebar_label:"Blocking Stream Reads with ServiceStack.Redis",slug:"/develop/dotnet/streams/blocking-reads/service-stack",authors:["steve"]},l=void 0,c={unversionedId:"develop/dotnet/streams/blocking-reads/service-stack/service-stack",id:"develop/dotnet/streams/blocking-reads/service-stack/service-stack",title:"How to handle blocking stream reads with ServiceStack.Redis",description:"ServiceStack.Redis is part of the ServiceStack suite, it has some restrictions when used for commercial purposes - see their license",source:"@site/docs/develop/dotnet/streams/blocking-reads/service-stack/service-stack.md",sourceDirName:"develop/dotnet/streams/blocking-reads/service-stack",slug:"/develop/dotnet/streams/blocking-reads/service-stack",permalink:"/develop/dotnet/streams/blocking-reads/service-stack",draft:!1,editUrl:"https://github.com/redis-developer/redis-developer/edit/master/docs/develop/dotnet/streams/blocking-reads/service-stack/service-stack.md",tags:[],version:"current",lastUpdatedAt:1655485542,formattedLastUpdatedAt:"6/17/2022",frontMatter:{id:"service-stack",title:"How to handle blocking stream reads with ServiceStack.Redis",sidebar_label:"Blocking Stream Reads with ServiceStack.Redis",slug:"/develop/dotnet/streams/blocking-reads/service-stack",authors:["steve"]},sidebar:"docs",previous:{title:"Blocking Stream Reads",permalink:"/develop/dotnet/streams/blocking-reads"},next:{title:"Blocking Stream Reads with CSRedis",permalink:"/develop/dotnet/streams/blocking-reads/cs-redis"}},d={},p=[{value:"Start Redis",id:"start-redis",level:2},{value:"Create the app",id:"create-the-app",level:2},{value:"Add the package to your app",id:"add-the-package-to-your-app",level:3},{value:"Initialize the client manager",id:"initialize-the-client-manager",level:3},{value:"Add items to streams",id:"add-items-to-streams",level:3},{value:"Reading messages",id:"reading-messages",level:3},{value:"Reading a stream outside a group with XREAD",id:"reading-a-stream-outside-a-group-with-xread",level:3},{value:"Reading with consumer groups",id:"reading-with-consumer-groups",level:3},{value:"Create the group and start the tasks",id:"create-the-group-and-start-the-tasks",level:3},{value:"Run the app",id:"run-the-app",level:2},{value:"Resources:",id:"resources",level:2}],u={toc:p};function m(e){var t=e.components,a=(0,r.Z)(e,s);return(0,i.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/ServiceStack/ServiceStack.Redis"},"ServiceStack.Redis")," is part of the ServiceStack suite, it has some restrictions when used for commercial purposes - see their ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ServiceStack/ServiceStack.Redis/blob/master/license.txt"},"license")),(0,i.kt)("h2",{id:"start-redis"},"Start Redis"),(0,i.kt)("p",null,"If you're developing locally (which is what we will assume for the balance of this tutorial), you can start Redis fairly quickly with docker:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"docker run -p 6379:6379 redis\n")),(0,i.kt)("h2",{id:"create-the-app"},"Create the app"),(0,i.kt)("p",null,"We will build a simple console application for streaming telemetry using the library. To do so, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"dotnet new")," command:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"dotnet new console -n StreamsWithServiceStack\n")),(0,i.kt)("h3",{id:"add-the-package-to-your-app"},"Add the package to your app"),(0,i.kt)("p",null,"You can add this package to your app with:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"dotnet add package ServiceStack.Redis\n")),(0,i.kt)("h3",{id:"initialize-the-client-manager"},"Initialize the client manager"),(0,i.kt)("p",null,"To initialize a client with ServiceStack, you'll need to create a ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ServiceStack/ServiceStack.Redis#redis-client-managers"},(0,i.kt)("inlineCode",{parentName:"a"},"RedisClientManager")),". Then, add the following to ",(0,i.kt)("inlineCode",{parentName:"p"},"Program.cs"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'var manager = new BasicRedisClientManager("localhost");\n')),(0,i.kt)("h3",{id:"add-items-to-streams"},"Add items to streams"),(0,i.kt)("p",null,"Redis streams are not yet fully supported by ServiceStack.Redis, however, you can run raw commands easily with the ",(0,i.kt)("inlineCode",{parentName:"p"},"CustomAsync")," method. So let's create a new class called ",(0,i.kt)("inlineCode",{parentName:"p"},"Producer.cs")," and add the following to it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'public static class Producer\n{\n    public static async Task Produce(BasicRedisClientManager manager, CancellationToken token)\n    {\n        var client = await manager.GetClientAsync(token);\n        var random = new Random();\n        while (!token.IsCancellationRequested)\n        {\n            await client.CustomAsync("XADD", "telemetry", "*", "temp",random.Next(50,65), "time", DateTimeOffset.Now.ToUnixTimeSeconds());\n            await Task.Delay(10000, token);\n        }\n    }\n}\n')),(0,i.kt)("p",null,"This code will send new telemetry every 10 seconds to the ",(0,i.kt)("inlineCode",{parentName:"p"},"telemetry")," stream, with a ",(0,i.kt)("inlineCode",{parentName:"p"},"temp")," record and a ",(0,i.kt)("inlineCode",{parentName:"p"},"time")," record."),(0,i.kt)("h3",{id:"reading-messages"},"Reading messages"),(0,i.kt)("p",null,"As mentioned earlier, ServiceStack does not have native support for the Streams API, so we need to do a bit of work after retrieving a record from a stream. However, this isn't a complex operation since the resulting structure is a predictable set of nested arrays going from an array of the streams requested to an array of messages retrieved from each stream to the message itself split between its id and its attributes. Finally, the field value pairs within a message; this looks something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'127.0.0.1:6379> XREAD COUNT 1 BLOCK 20000 STREAMS telemetry $\n1) 1) "telemetry"\n   2) 1) 1) "1642857504469-0"\n         2) 1) "temp"\n            2) "57"\n            3) "time"\n            4) "1642857504"\n')),(0,i.kt)("p",null,"This data structure is pretty predictable to parse, so we'll add a little parsing method. First, Create ",(0,i.kt)("inlineCode",{parentName:"p"},"Consumer.cs")," and add the following to it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"using ServiceStack.Redis;\n\nnamespace StreamsWithServicestack;\n\npublic static class Consumer\n{\n    public static IDictionary<string, string> ParseStreamResult(RedisText text, out string id)\n    {\n        var result = new Dictionary<string, string>();\n\n        var fieldValPairs = text.Children[0].Children[1].Children[0].Children[1].Children;\n        id = text.Children[0].Children[1].Children[0].Children[0].Text;\n        for (var i = 0; i < fieldValPairs.Count; i += 2)\n        {\n            result.Add(fieldValPairs[i].Text, fieldValPairs[i+1].Text);\n        }\n\n        return result;\n    }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ParseStreamResult")," will yield the first message from the first stream of an ",(0,i.kt)("inlineCode",{parentName:"p"},"XREAD")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"XREADGROUP"),", this isn't a fully generalized solution but will serve our purposes here."),(0,i.kt)("h3",{id:"reading-a-stream-outside-a-group-with-xread"},"Reading a stream outside a group with XREAD"),(0,i.kt)("p",null,"To read the next message in a stream, which is necessarily a blocking operation, you will use the ",(0,i.kt)("inlineCode",{parentName:"p"},"XREAD")," command with the ",(0,i.kt)("inlineCode",{parentName:"p"},"BLOCK")," option and the special ",(0,i.kt)("inlineCode",{parentName:"p"},"$")," id. Then, in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Consumer")," class, add the following, which will read off the stream in a continuous loop, blocking for 20 seconds at each request."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'public static async Task Consume(IRedisClientsManagerAsync manager, CancellationToken token)\n{\n    var client = await manager.GetClientAsync(token);\n    while (!token.IsCancellationRequested)\n    {\n        string id;\n        var result = await client.CustomAsync("XREAD", "COUNT", 1, "BLOCK", 20000, "STREAMS", "telemetry", "$");\n        var fvp = ParseStreamResult(result, out id);\n        Console.WriteLine($"read: result {id} - temp: {fvp["temp"]} time: {fvp["time"]}");\n    }\n}\n')),(0,i.kt)("h3",{id:"reading-with-consumer-groups"},"Reading with consumer groups"),(0,i.kt)("p",null,"Reading messages in a consumer group can be helpful in cases where you have a common task that you want to distribute across many consumers in a high-throughput environment. It's a two-step process:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Read the stream"),(0,i.kt)("li",{parentName:"ol"},"Acknowledge receipt of the message")),(0,i.kt)("p",null,"This task can be done by running an ",(0,i.kt)("inlineCode",{parentName:"p"},"XREADGROUP")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"XACK")," back to back. The ",(0,i.kt)("inlineCode",{parentName:"p"},"XREADGROUP")," will take, in addition to the parameters we spoke about for the ",(0,i.kt)("inlineCode",{parentName:"p"},"XREAD"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"GROUP")," name, the consumer's name, and instead of taking the special ",(0,i.kt)("inlineCode",{parentName:"p"},"$")," id, it will take the special ",(0,i.kt)("inlineCode",{parentName:"p"},">")," id, which will have it take the next unassigned id for the group. We'll then extract the information from it, update our average, and then acknowledge the receipt of the message."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'public static async Task ConsumeFromGroup(IRedisClientsManagerAsync manager, CancellationToken token)\n{\n    var client = await manager.GetClientAsync(token);\n    var total = 0;\n    var num = 0;\n    while (!token.IsCancellationRequested)\n    {\n        string id;\n        var result = await client.CustomAsync("XREADGROUP", "GROUP", "avg", "avg-1", "COUNT", "1", "BLOCK",\n            20000, "STREAMS", "telemetry", ">");\n        var fvp = ParseStreamResult(result, out id);\n        total += int.Parse(fvp["temp"]);\n        num++;\n        Console.WriteLine(\n            $"Group-read: result {id} - temp: {fvp["temp"]} time: {fvp["time"]}, current average: {total / num}");\n        await client.CustomAsync("XACK", "telemetry", "avg", id);\n    }\n}\n')),(0,i.kt)("h3",{id:"create-the-group-and-start-the-tasks"},"Create the group and start the tasks"),(0,i.kt)("p",null,"The final bit we need is to create the group and start up all the tasks. We'll use the ",(0,i.kt)("inlineCode",{parentName:"p"},"XGROUP")," command with the ",(0,i.kt)("inlineCode",{parentName:"p"},"MKSTREAM")," option to create the group. We'll then start up all the tasks we need for our producer and consumers, and we'll await everything. Add the following to your ",(0,i.kt)("inlineCode",{parentName:"p"},"Program.cs")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'using ServiceStack.Redis;\nusing StreamsWithServicestack;\n\nvar manager = new BasicRedisClientManager("localhost");\nvar asyncClient = await manager.GetClientAsync();\n\nvar tokenSource = new CancellationTokenSource();\nvar token = tokenSource.Token;\n\ntry\n{\n    await asyncClient.CustomAsync("XGROUP", "CREATE", "telemetry", "avg", "0-0", "MKSTREAM");\n}\ncatch (Exception ex)\n{\n    Console.WriteLine(ex);\n}\n\nvar writeTask = Producer.Produce(manager, token);\nvar readTask = Consumer.Consume(manager, token);\nvar groupReadTask = Consumer.ConsumeFromGroup(manager, token);\n\nawait Task.WhenAll(writeTask, readTask, groupReadTask);\n\n')),(0,i.kt)("h2",{id:"run-the-app"},"Run the app"),(0,i.kt)("p",null,"All that's left to do is to run the app, and you'll see a continuous stream of messages coming in every 10 seconds. You can run the app by running:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"dotnet run\n")),(0,i.kt)("h2",{id:"resources"},"Resources:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The source for this tutorial is in ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/redis-developer/redis-streams-with-dotnet/tree/main/StreamsWithServicestack"},"GitHub")),(0,i.kt)("li",{parentName:"ul"},"Redis University has an extensive ",(0,i.kt)("a",{parentName:"li",href:"https://university.redis.com/courses/ru202/"},"course")," on Redis Streams where you can learn everything you need to know about them."),(0,i.kt)("li",{parentName:"ul"},"You can learn more about Redis Streams in the ",(0,i.kt)("a",{parentName:"li",href:"https://redis.io/topics/streams-intro"},"Streams Info")," article on redis.io")))}m.isMDXComponent=!0}}]);