"use strict";(self.webpackChunkredis_developer_hub=self.webpackChunkredis_developer_hub||[]).push([[37],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),d=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=d(e.components);return i.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},c=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=d(n),m=a,h=c["".concat(s,".").concat(m)]||c[m]||u[m]||r;return n?i.createElement(h,l(l({ref:t},p),{},{components:n})):i.createElement(h,l({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var d=2;d<r;d++)l[d]=n[d];return i.createElement.apply(null,l)}return i.createElement.apply(null,n)}c.displayName="MDXCreateElement"},98419:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var i=n(87462),a=(n(67294),n(3905));const r={id:"byo-rate-limiter-middleware",title:"Configurable Sliding Window Rate Limiting Middleware for Redis & ASP.NET Core",sidebar_label:"Rate Limiting Middleware",slug:"/develop/dotnet/aspnetcore/rate-limiting/middleware",authors:["steve"]},l=void 0,o={unversionedId:"develop/dotnet/aspnetcore/rate-limiting/middleware/byo-rate-limiter-middleware",id:"develop/dotnet/aspnetcore/rate-limiting/middleware/byo-rate-limiter-middleware",title:"Configurable Sliding Window Rate Limiting Middleware for Redis & ASP.NET Core",description:"Let's consider the case (which is probably most cases) where we have multiple endpoints we want to rate limit; it doesn't make an awful lot of sense to embed rate-limiting in those cases in the logic of the routes themselves. Instead, have something that will intercept requests and check to see if the request is rate-limited before moving onto the appropriate endpoint. To accomplish this, we'll build some middleware for just this purpose. And with some light configuration work, we'll be able to build some middleware to handle a configurable set of limits.",source:"@site/docs/develop/dotnet/aspnetcore/rate-limiting/middleware/byo-rate-limiting-middleware.md",sourceDirName:"develop/dotnet/aspnetcore/rate-limiting/middleware",slug:"/develop/dotnet/aspnetcore/rate-limiting/middleware",permalink:"/develop/dotnet/aspnetcore/rate-limiting/middleware",draft:!1,editUrl:"https://github.com/redis-developer/redis-developer/edit/master/docs/develop/dotnet/aspnetcore/rate-limiting/middleware/byo-rate-limiting-middleware.md",tags:[],version:"current",lastUpdatedAt:1655485542,formattedLastUpdatedAt:"Jun 17, 2022",frontMatter:{id:"byo-rate-limiter-middleware",title:"Configurable Sliding Window Rate Limiting Middleware for Redis & ASP.NET Core",sidebar_label:"Rate Limiting Middleware",slug:"/develop/dotnet/aspnetcore/rate-limiting/middleware",authors:["steve"]},sidebar:"docs",previous:{title:"Sliding Window Rate Limiting app  using ASP.NET",permalink:"/develop/dotnet/aspnetcore/rate-limiting/sliding-window"},next:{title:"Basic API Caching using ASP.NET Core",permalink:"/develop/dotnet/aspnetcore/caching/basic-api-caching"}},s={},d=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Startup Redis",id:"startup-redis",level:2},{value:"Create Project",id:"create-project",level:2},{value:"Create Configuration Object",id:"create-configuration-object",level:2},{value:"Build Config Object",id:"build-config-object",level:3},{value:"Time Regex",id:"time-regex",level:4},{value:"Time Unit Enum",id:"time-unit-enum",level:4},{value:"Parse Time",id:"parse-time",level:4},{value:"Add properties",id:"add-properties",level:4},{value:"Match Path",id:"match-path",level:4},{value:"Writing our Lua Script",id:"writing-our-lua-script",level:2},{value:"Build The Middleware",id:"build-the-middleware",level:2},{value:"Constructor",id:"constructor",level:3},{value:"Extract Api Key",id:"extract-api-key",level:3},{value:"Extract Applicable Rules",id:"extract-applicable-rules",level:3},{value:"Check Limitation",id:"check-limitation",level:3},{value:"Block or Allow",id:"block-or-allow",level:3},{value:"Build Controller",id:"build-controller",level:2},{value:"Add Middleware to App",id:"add-middleware-to-app",level:2},{value:"Configure the App",id:"configure-the-app",level:2},{value:"Test it Out",id:"test-it-out",level:2},{value:"Resources",id:"resources",level:2}],p={toc:d};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Let's consider the case (which is probably most cases) where we have multiple endpoints we want to rate limit; it doesn't make an awful lot of sense to embed rate-limiting in those cases in the logic of the routes themselves. Instead, have something that will intercept requests and check to see if the request is rate-limited before moving onto the appropriate endpoint. To accomplish this, we'll build some middleware for just this purpose. And with some light configuration work, we'll be able to build some middleware to handle a configurable set of limits."),(0,a.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Must have the ",(0,a.kt)("a",{parentName:"li",href:"https://dotnet.microsoft.com/download/dotnet/5.0"},".NET 5+ SDK")," installed"),(0,a.kt)("li",{parentName:"ul"},"Some way of running Redis, for this tutorial we'll use ",(0,a.kt)("a",{parentName:"li",href:"https://www.docker.com/products/docker-desktop"},"Docker Desktop")),(0,a.kt)("li",{parentName:"ul"},"IDE for writing C# ",(0,a.kt)("a",{parentName:"li",href:"https://code.visualstudio.com/download"},"VS Code"),", ",(0,a.kt)("a",{parentName:"li",href:"https://visualstudio.microsoft.com/"},"Visual Studio"),", or ",(0,a.kt)("a",{parentName:"li",href:"https://www.jetbrains.com/rider/"},"Rider"))),(0,a.kt)("h2",{id:"startup-redis"},"Startup Redis"),(0,a.kt)("p",null,"Before we begin, startup Redis. For this example, we'll use the ",(0,a.kt)("a",{parentName:"p",href:"https://hub.docker.com/_/redis"},"Redis docker image"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"docker run -p 6379:6379 redis\n")),(0,a.kt)("h2",{id:"create-project"},"Create Project"),(0,a.kt)("p",null,"In your terminal, navigate to where you want the app to live and run:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"dotnet new webapi -n RateLimitingMiddleware --no-https\n")),(0,a.kt)("p",null,"Cd into the ",(0,a.kt)("inlineCode",{parentName:"p"},"RateLimitingMiddleware")," folder and run the command ",(0,a.kt)("inlineCode",{parentName:"p"},"dotnet add package StackExchange.Redis"),"."),(0,a.kt)("p",null,"Open ",(0,a.kt)("inlineCode",{parentName:"p"},"RateLimitingMiddleware.csproj")," in Rider, Visual Studio, or open the folder in VS Code. Then, in the ",(0,a.kt)("inlineCode",{parentName:"p"},"Controllers")," folder, add an API controller called ",(0,a.kt)("inlineCode",{parentName:"p"},"RateLimitedController"),". When all this is complete, ",(0,a.kt)("inlineCode",{parentName:"p"},"RateLimitedController.cs")," should look like the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'namespace SlidingWindowRateLimiter.Controllers\n{\n    [ApiController]\n    [Route("api/[controller]")]\n    public class RateLimitedController : ControllerBase\n    {\n    }\n}\n')),(0,a.kt)("h2",{id:"create-configuration-object"},"Create Configuration Object"),(0,a.kt)("p",null,"Now it's time to dig into the logic behind this middleware. The first thing we ought to do is consider the configurations we will use to configure our middleware. We'll consider configuration objects to contain the following form in our application configuration:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "RedisRateLimits": [\n    {\n      "Path": "/api/ratelimited/limited",\n      "Window": "30s",\n      "MaxRequests": 5\n    },\n    {\n      "PathRegex": "/api/*",\n      "Window": "1d",\n      "MaxRequests": 1000\n    }\n  ]\n}\n')),(0,a.kt)("p",null,"In other words, we have four parameters."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Parameter Name"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"),(0,a.kt)("th",{parentName:"tr",align:null}),(0,a.kt)("th",{parentName:"tr",align:null}),(0,a.kt)("th",{parentName:"tr",align:null}))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Path"),(0,a.kt)("td",{parentName:"tr",align:null},"literal path to be rate-limited if the path matches completely, it will trigger a rate limit check"),(0,a.kt)("td",{parentName:"tr",align:null}),(0,a.kt)("td",{parentName:"tr",align:null}),(0,a.kt)("td",{parentName:"tr",align:null})),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"PathRegex"),(0,a.kt)("td",{parentName:"tr",align:null},"Path regex to be rate-limited; if path matches, it will trigger a rate limit check"),(0,a.kt)("td",{parentName:"tr",align:null}),(0,a.kt)("td",{parentName:"tr",align:null}),(0,a.kt)("td",{parentName:"tr",align:null})),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Window"),(0,a.kt)("td",{parentName:"tr",align:null},"The Sliding Window to Rate Limit on should match the pattern `(","[0-9]","+(s"),(0,a.kt)("td",{parentName:"tr",align:null},"m"),(0,a.kt)("td",{parentName:"tr",align:null},"d"),(0,a.kt)("td",{parentName:"tr",align:null},"h))`")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"MaxRequests"),(0,a.kt)("td",{parentName:"tr",align:null},"The maximum number of requests allowable over the period"),(0,a.kt)("td",{parentName:"tr",align:null}),(0,a.kt)("td",{parentName:"tr",align:null}),(0,a.kt)("td",{parentName:"tr",align:null})))),(0,a.kt)("p",null,"And those parameters are going to be stored under the configuration node ",(0,a.kt)("inlineCode",{parentName:"p"},"RedisRateLimits")," in our configuration."),(0,a.kt)("h3",{id:"build-config-object"},"Build Config Object"),(0,a.kt)("p",null,"The configuration objects we'll use for this will contain the logic of the rule and some parsing logic to handle parsing the timeouts from the window pattern. So we'll create a new class called ",(0,a.kt)("inlineCode",{parentName:"p"},"RateLimitRule")," In this class, we'll add a regex to do the pattern matching for our window:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public class RateLimitRule\n{\n\n}\n")),(0,a.kt)("h4",{id:"time-regex"},"Time Regex"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'private static readonly Regex TimePattern = new ("([0-9]+(s|m|d|h))");\n')),(0,a.kt)("h4",{id:"time-unit-enum"},"Time Unit Enum"),(0,a.kt)("p",null,"Then we'll create an enum that we'll store the unit half of the window size in:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"private enum TimeUnit\n{\n    s = 1,\n    m = 60,\n    h = 3600,\n    d = 86400\n}\n")),(0,a.kt)("h4",{id:"parse-time"},"Parse Time"),(0,a.kt)("p",null,"We are going to measure time windows in seconds (as that will be the most native thing for Redis), so we will now need to have a method to convert our time window to seconds:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'private static int ParseTime(string timeStr)\n{\n    var match = TimePattern.Match(timeStr);\n    if (string.IsNullOrEmpty(match.Value))\n        throw new ArgumentException("Rate limit window was not provided or was not " +\n                                    "properly formatted, must be of the form ([0-9]+(s|m|d|h))");\n    var unit = Enum.Parse<TimeUnit>(match.Value.Last().ToString());\n    var num = int.Parse(match.Value.Substring(0, match.Value.Length - 1));\n    return num * (int) unit;\n}\n')),(0,a.kt)("h4",{id:"add-properties"},"Add properties"),(0,a.kt)("p",null,"Next, we'll need to add the Properties of this class so that we don't have to repeat computation. We'll store ",(0,a.kt)("inlineCode",{parentName:"p"},"_windowSeconds")," in a separate private field:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public string Path { get; set; }\npublic string PathRegex { get; set; }\npublic string Window { get; set; }\npublic int MaxRequests { get; set; }\ninternal int _windowSeconds = 0;\ninternal string PathKey => string.IsNullOrEmpty(Path) ? Path : PathRegex;\ninternal int WindowSeconds\n{\n    get\n    {\n        if (_windowSeconds < 1)\n        {\n            _windowSeconds = ParseTime(Window);\n        }\n        return _windowSeconds;\n    }\n}\n")),(0,a.kt)("h4",{id:"match-path"},"Match Path"),(0,a.kt)("p",null,"Finally, we'll perform the pattern matching against the path:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public bool MatchPath(string path)\n{\n    if (!string.IsNullOrEmpty(Path))\n    {\n        return path.Equals(Path, StringComparison.InvariantCultureIgnoreCase);\n    }\n    if (!string.IsNullOrEmpty(PathRegex))\n    {\n        return Regex.IsMatch(path, PathRegex);\n    }\n    return false;\n}\n")),(0,a.kt)("h2",{id:"writing-our-lua-script"},"Writing our Lua Script"),(0,a.kt)("p",null,"We need to write a Lua script that will consider all the rules applicable to a particular user on a specific endpoint. We'll use sorted sets to check the rate limits for each rule and user. On each request, it will take each applicable rule and:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Check the current time"),(0,a.kt)("li",{parentName:"ol"},"Trim off entries that fall outside the window"),(0,a.kt)("li",{parentName:"ol"},"Check if another request violates the rule",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"If the request would violate any rules return 1"))),(0,a.kt)("li",{parentName:"ol"},"For each applicable rule"),(0,a.kt)("li",{parentName:"ol"},"Add a new entry to the sorted set with the score of the current time in seconds, and a member name of the current time in microseconds"),(0,a.kt)("li",{parentName:"ol"},"Return 0")),(0,a.kt)("p",null,"As we have an undetermined number of rules ahead of time, it's impossible to use the StackExchange.Redis Library's, but we can still use a Lua script to accomplish this."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"local current_time = redis.call('TIME')\nlocal num_windows = ARGV[1]\nfor i=2, num_windows*2, 2 do\n    local window = ARGV[i]\n    local max_requests = ARGV[i+1]\n    local curr_key = KEYS[i/2]\n    local trim_time = tonumber(current_time[1]) - window\n    redis.call('ZREMRANGEBYSCORE', curr_key, 0, trim_time)\n    local request_count = redis.call('ZCARD',curr_key)\n    if request_count >= tonumber(max_requests) then\n        return 1\n    end\nend\nfor i=2, num_windows*2, 2 do\n    local curr_key = KEYS[i/2]\n    local window = ARGV[i]\n    redis.call('ZADD', curr_key, current_time[1], current_time[1] .. current_time[2])\n    redis.call('EXPIRE', curr_key, window)\nend\nreturn 0\n")),(0,a.kt)("p",null,"The above script has an undetermined number of arguments and an undetermined number of keys ahead of time. As such, it's essential to make sure that all the keys are on the same shard, so when we build the keys, which will be of the form ",(0,a.kt)("inlineCode",{parentName:"p"},"path_pattern:apiKey:window_size_seconds"),", we will surround the common part of the key ",(0,a.kt)("inlineCode",{parentName:"p"},"apiKey")," with braces ",(0,a.kt)("inlineCode",{parentName:"p"},"{apiKey}"),"."),(0,a.kt)("h2",{id:"build-the-middleware"},"Build The Middleware"),(0,a.kt)("p",null,"Now it's time to actually build the middleware. Add a new file ",(0,a.kt)("inlineCode",{parentName:"p"},"SlidingWindowRateLimiter.cs")," Inside that file, add two classes ",(0,a.kt)("inlineCode",{parentName:"p"},"SlidingWindowRateLimiter")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"SlidingWindowRateLimiterExtensions")),(0,a.kt)("p",null,"In the ",(0,a.kt)("inlineCode",{parentName:"p"},"SlidingWindowRateLimiterExtensions")," class, add one method to add the SlidingWIndowRateLimiter to the middleware pipeline, that class will look like this when completed:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public static class SlidingWindowRateLimiterExtensions\n{\n    public static void UseSlidingWindowRateLimiter(this IApplicationBuilder builder)\n    {\n        builder.UseMiddleware<SlidingWindowRateLimiter>();\n    }\n}\n")),(0,a.kt)("p",null,"In the ",(0,a.kt)("inlineCode",{parentName:"p"},"SlidingWindowRateLimiter")," class, start by adding the script mentioned above as a const string for the class:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"private const string SlidingRateLimiter = @\"\n    local current_time = redis.call('TIME')\n    local num_windows = ARGV[1]\n    for i=2, num_windows*2, 2 do\n        local window = ARGV[i]\n        local max_requests = ARGV[i+1]\n        local curr_key = KEYS[i/2]\n        local trim_time = tonumber(current_time[1]) - window\n        redis.call('ZREMRANGEBYSCORE', curr_key, 0, trim_time)\n        local request_count = redis.call('ZCARD',curr_key)\n        if request_count >= tonumber(max_requests) then\n            return 1\n        end\n    end\n    for i=2, num_windows*2, 2 do\n        local curr_key = KEYS[i/2]\n        local window = ARGV[i]\n        redis.call('ZADD', curr_key, current_time[1], current_time[1] .. current_time[2])\n        redis.call('EXPIRE', curr_key, window)\n    end\n    return 0\n    \";\n")),(0,a.kt)("h3",{id:"constructor"},"Constructor"),(0,a.kt)("p",null,"We need to seed this class with an ",(0,a.kt)("inlineCode",{parentName:"p"},"IDatabase")," to access redis, an ",(0,a.kt)("inlineCode",{parentName:"p"},"IConfiguration")," to access the configuration, and of course, the next chain in the pipeline to continue. So consequentially, we'll dependency inject all this into our middleware:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"private readonly IDatabase _db;\nprivate readonly IConfiguration _config;\nprivate readonly RequestDelegate _next;\n\npublic SlidingWindowRateLimiter(RequestDelegate next, IConnectionMultiplexer muxer, IConfiguration config)\n{\n    _db = muxer.GetDatabase();\n    _config = config;\n    _next = next;\n}\n")),(0,a.kt)("h3",{id:"extract-api-key"},"Extract Api Key"),(0,a.kt)("p",null,"In this case, we will use ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Basic_access_authentication"},"basic auth"),", so we will be using the username from the basic auth structure as our ",(0,a.kt)("inlineCode",{parentName:"p"},"apiKey"),". We will need a method to extract it consequentially:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"private static string GetApiKey(HttpContext context)\n{\n    var encoded = string.Empty;\n    var auth = context.Request.Headers[\"Authorization\"];\n    if (!string.IsNullOrEmpty(auth)) encoded = AuthenticationHeaderValue.Parse(auth).Parameter;\n    if (string.IsNullOrEmpty(encoded)) return encoded;\n    return Encoding.UTF8.GetString(Convert.FromBase64String(encoded)).Split(':')[0];\n}\n")),(0,a.kt)("h3",{id:"extract-applicable-rules"},"Extract Applicable Rules"),(0,a.kt)("p",null,"From the configuration structure we generated before, we will pull out the ",(0,a.kt)("inlineCode",{parentName:"p"},"RedisRateLimits")," section and stuff it into an array of ",(0,a.kt)("inlineCode",{parentName:"p"},"RateLimitRule")," objects. We then need to pull out the rules that apply to the current path, group them by the number of seconds in their windows and by the path key component that's relevant for them. If we have identical path keys, e.g., two instances of ",(0,a.kt)("inlineCode",{parentName:"p"},"^/api/*"),", we'll take the more restrictive one(fewest allowable requests). We can pull the with a LINQ query:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'public IEnumerable<RateLimitRule> GetApplicableRules(HttpContext context)\n{\n    var limits = _config.GetSection("RedisRateLimits").Get<RateLimitRule[]>();\n    var applicableRules = limits\n        .Where(x => x.MatchPath(context.Request.Path))\n        .OrderBy(x => x.MaxRequests)\n        .GroupBy(x => new{x.PathKey, x.WindowSeconds})\n        .Select(x=>x.First());\n    return applicableRules;\n}\n')),(0,a.kt)("h3",{id:"check-limitation"},"Check Limitation"),(0,a.kt)("p",null,"Our next step is to check to see if the key is currently under a limitation. Our script expects an array of redis keys of the pattern mentioned above ",(0,a.kt)("inlineCode",{parentName:"p"},"path_pattern:{apiKey}:window_size_seconds"),", then it needs the number of rules to be enforced, and finally, it needs the rules appended in ",(0,a.kt)("inlineCode",{parentName:"p"},"window_size")," ",(0,a.kt)("inlineCode",{parentName:"p"},"num_requests")," order. With the arguments all generated for the script, all we need to do is to evaluate the script and check if it returns one or not:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'private async Task<bool> IsLimited( IEnumerable<RateLimitRule> rules, string apiKey)\n{\n    var keys = rules.Select(x => new RedisKey($"{x.PathKey}:{{{apiKey}}}:{x.WindowSeconds}")).ToArray();\n    var args = new List<RedisValue>{rules.Count()};\n    foreach (var rule in rules)\n    {\n        args.Add(rule.WindowSeconds);\n        args.Add(rule.MaxRequests);\n    }\n    return (int) await _db.ScriptEvaluateAsync(SlidingRateLimiter, keys,args.ToArray()) == 1;\n}\n')),(0,a.kt)("h3",{id:"block-or-allow"},"Block or Allow"),(0,a.kt)("p",null,"Finally, in the ",(0,a.kt)("inlineCode",{parentName:"p"},"InvokeAsync")," method for our middleware, we will glue all this together. First, we'll parse out the apiKey. If the apiKey isn't present, we'll return a 401. Otherwise, we will perform the rate-limiting checks and either throttle or proceed as appropriate."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public async Task InvokeAsync(HttpContext httpContext)\n{\n    var apiKey = GetApiKey(httpContext);\n    if (string.IsNullOrEmpty(apiKey))\n    {\n        httpContext.Response.StatusCode = 401;\n        return;\n    }\n    var applicableRules = GetApplicableRules(httpContext);\n    var limited = await IsLimited(applicableRules, apiKey);\n    if (limited)\n    {\n        httpContext.Response.StatusCode = 429;\n        return;\n    }\n    await _next(httpContext);\n}\n")),(0,a.kt)("h2",{id:"build-controller"},"Build Controller"),(0,a.kt)("p",null,"Under the ",(0,a.kt)("inlineCode",{parentName:"p"},"Controllers")," Folder, add a class named ",(0,a.kt)("inlineCode",{parentName:"p"},"RateLimitedController"),". Then, in this controller, declare a new ApiController."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'[ApiController]\n[Route("api/[controller]")]\npublic class RateLimitedController : ControllerBase\n{\n}\n')),(0,a.kt)("p",null,"In this class, add two new routes, one to ",(0,a.kt)("inlineCode",{parentName:"p"},"limited")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"indirectly-limited")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'[HttpGet]\n[HttpPost]\n[Route("limited")]\npublic async Task<IActionResult> Limited()\n{\n    return new JsonResult(new {Limited = false});\n}\n\n[HttpGet]\n[HttpPost]\n[Route("indirectly-limited")]\npublic async Task<IActionResult> IndirectlyLimited()\n{\n    return new JsonResult(new {NeverLimited = true});\n}\n')),(0,a.kt)("h2",{id:"add-middleware-to-app"},"Add Middleware to App"),(0,a.kt)("p",null,"Open up ",(0,a.kt)("inlineCode",{parentName:"p"},"startup.cs")),(0,a.kt)("p",null,"In the ",(0,a.kt)("inlineCode",{parentName:"p"},"ConfigureServices")," method, add the following line:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'services.AddSingleton<IConnectionMultiplexer>(ConnectionMultiplexer.Connect("localhost"));\n')),(0,a.kt)("p",null,"In the method ",(0,a.kt)("inlineCode",{parentName:"p"},"Configure")," method, add the following line:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"app.UseSlidingWindowRateLimiter();\n")),(0,a.kt)("h2",{id:"configure-the-app"},"Configure the App"),(0,a.kt)("p",null,"In ",(0,a.kt)("inlineCode",{parentName:"p"},"appsettings.json"),", or ",(0,a.kt)("inlineCode",{parentName:"p"},"appsettings.Development.json"),", add a configuration item for the rate limits:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'"RedisRateLimits":[\n    {\n      "Path":"/api/RateLimited/limited",\n      "Window":"30s",\n      "MaxRequests": 5\n    },\n    {\n      "PathRegex":"^/api/*",\n      "Window":"1h",\n      "MaxRequests": 50\n    }\n]\n')),(0,a.kt)("h2",{id:"test-it-out"},"Test it Out"),(0,a.kt)("p",null,"All that's left is to test it out. If you go to your terminal and run ",(0,a.kt)("inlineCode",{parentName:"p"},"dotnet run")," you can try out each of the two endpoints they are available at"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"http://localhost:5000/api/ratelimited/limited")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"http://localhost:5000/api/ratelimited/indirectly-limited")),(0,a.kt)("p",null,"You can hit these endpoints repeatedly using:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'for n in {1..7}; do echo $(curl -s -w " HTTP %{http_code}, %{time_total} s" -X POST -H "Content-Length: 0" --user "foobar:password" http://localhost:5000/api/ratelimited/limited); sleep 0.5; done\n')),(0,a.kt)("p",null,"Which will send seven requests, two of which will be rejected after that if you run"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'for n in {1..47}; do echo $(curl -s -w " HTTP %{http_code}, %{time_total} s" -X POST -H "Content-Length: 0" --user "foobar:password" http://localhost:5000/api/ratelimited/indirectly-limited); sleep 0.5; done\n')),(0,a.kt)("p",null,"It should reject another two as throttled."),(0,a.kt)("h2",{id:"resources"},"Resources"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The source code for this tutorial is located in ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/redis-developer/rate-limiting-middleware-aspnetcore"},"GitHub"))))}u.isMDXComponent=!0}}]);