"use strict";(self.webpackChunkredis_developer_hub=self.webpackChunkredis_developer_hub||[]).push([[4698],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var n=a(67294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},c=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=d(a),m=o,h=u["".concat(l,".").concat(m)]||u[m]||p[m]||i;return a?n.createElement(h,s(s({ref:t},c),{},{components:a})):n.createElement(h,s({ref:t},c))}));function m(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=a.length,s=new Array(i);s[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:o,s[1]=r;for(var d=2;d<i;d++)s[d]=a[d];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},38471:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>d,toc:()=>p});var n=a(87462),o=a(67294),i=a(3905);const s=function(e){let{cta:t,image:a,title:n,children:i}=e;return o.createElement(o.Fragment,null,o.createElement("p",null,"Below you will find an excerpt from the e-book."," ",o.createElement("a",{href:t,target:"_blank"},"Click here to download the full e-book.")),o.createElement("div",{className:"margin-bottom--xs"},o.createElement("img",{src:a,loading:"lazy",alt:n})),i,o.createElement("p",null,"I\u2019m sure you\u2019re eager to learn more, so"," ",o.createElement("a",{href:t,target:"_blank"},"click here to download the full e-book.")))},r={id:"nosql-data-modeling-patterns",title:"Learn 8 NoSQL Data Modeling Patterns in Redis",image:"/img/ebooks/nosql-data-modeling-patterns/8-data-modeling-patterns-in-redis.jpg",sidebar_label:"NoSQL Data Modeling Patterns",slug:"/ebooks/8-nosql-data-modeling-patterns",editUrl:!1,showLastUpdateTime:!1},l=void 0,d={unversionedId:"ebooks/nosql-data-modeling-patterns",id:"ebooks/nosql-data-modeling-patterns",title:"Learn 8 NoSQL Data Modeling Patterns in Redis",description:"Introduction",source:"@site/docs/ebooks/nosql-data-modeling-patterns.mdx",sourceDirName:"ebooks",slug:"/ebooks/8-nosql-data-modeling-patterns",permalink:"/ebooks/8-nosql-data-modeling-patterns",draft:!1,editUrl:"https://github.com/redis-developer/redis-developer/edit/master/docs/ebooks/nosql-data-modeling-patterns.mdx",tags:[],version:"current",lastUpdatedAt:1668181892,formattedLastUpdatedAt:"Nov 11, 2022",frontMatter:{id:"nosql-data-modeling-patterns",title:"Learn 8 NoSQL Data Modeling Patterns in Redis",image:"/img/ebooks/nosql-data-modeling-patterns/8-data-modeling-patterns-in-redis.jpg",sidebar_label:"NoSQL Data Modeling Patterns",slug:"/ebooks/8-nosql-data-modeling-patterns",editUrl:!1,showLastUpdateTime:!1},sidebar:"docs",previous:{title:"DEVcember",permalink:"/devcember/"}},c={},p=[{value:"Introduction",id:"introduction",level:2},{value:"SQL versus NoSQL",id:"sql-versus-nosql",level:2},{value:"Modeling 1-to-1 Relationships",id:"modeling-1-to-1-relationships",level:2},{value:"1-to-1 Relationships using SQL",id:"1-to-1-relationships-using-sql",level:3},{value:"1-to-1 Relationships using Redis",id:"1-to-1-relationships-using-redis",level:3},{value:"Download the E-book",id:"download-the-e-book",level:2}],u={toc:p};function m(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)(s,{cta:"https://redis.com/docs/8-data-modeling-patterns-in-redis/",image:r.image,title:r.title,mdxType:"Excerpt"},(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"When someone is looking to use NoSQL for an application, the question that most often comes up is, \u201cHow do I structure\nmy data?\u201d The short answer to this question is, as you might guess, it depends. There are several questions that can\ninform how to structure your data in a NoSQL database.\nIs your application read heavy, or write heavy? What does the user experience of your application look like? How does\nyour data need to be presented to the user? How much data will you be storing? What performance considerations do\nyou need to account for? How do you anticipate scaling your application?"),(0,i.kt)("p",null,"These questions are only a small subset of what you need to ask yourself when you start working with NoSQL. A common\nmisconception with NoSQL databases is that since they are \u201cschemaless\u201d you don\u2019t need to worry about your schema.\nIn reality, your schema is incredibly important regardless of what database you choose. You also need to ensure that the\nschema you choose will scale well with the database you plan to use."),(0,i.kt)("p",null,"In this e-book you will learn how to approach data modeling in NoSQL, specifically within the context of Redis. Redis is a\ngreat database for demonstrating several NoSQL patterns and practices. Not only is Redis commonly used and loved by\ndevelopers, it also is a multi-model database. This means that while many of the patterns covered in this e-book apply to\ndifferent types of databases (e.g. document, graph, time series, etc.), with Redis you can apply all of the patterns in\na single database."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"By the end of this, you should have"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"A firm understanding of how to approach modeling data in Redis as well as in NoSQL generally."),(0,i.kt)("li",{parentName:"ul"},"An understanding of several NoSQL data modeling patterns, their pros and cons, as well as use cases for\nthem in practice."),(0,i.kt)("li",{parentName:"ul"},"A working knowledge of how to actually write code (with examples) to take advantage of NoSQL patterns\nwithin Redis."))),(0,i.kt)("h2",{id:"sql-versus-nosql"},"SQL versus NoSQL"),(0,i.kt)("p",null,"I\u2019m sure at a certain level you understand the difference between SQL and NoSQL. SQL is a structured query language\nwhereas NoSQL can mean several different things depending on the context. However, generally speaking, the approach\nto modeling data is fundamentally different in NoSQL than in SQL. There are also differences in terms of scalability, with\nNoSQL being easier to scale horizontally."),(0,i.kt)("p",null,"When building applications you are probably using an object-oriented language like JavaScript, Java, C#, or others.\nYour data is represented as strings, lists, sets, hashes, JSON, and so on. However, if you store data in a SQL database\nor a document database, you need to squeeze and transform the data into several tables or collections. You also need\ncomplex queries (such as SQL queries) to get the data out. This is called ",(0,i.kt)("strong",{parentName:"p"},"impedance mismatch")," and is the fundamental\nreason why NoSQL exists."),(0,i.kt)("p",null,"A large application might use other systems for data storage such as Neo4J for graph data, MongoDB for document\ndata, InfluxDB for time series, etc. Using separate databases turns an impedance mismatch problem into a database\norchestration problem. You have to juggle multiple connections to different databases, as well as learn the different client\nlibraries used."),(0,i.kt)("p",null,"With Redis, in addition to the basic data structures such as strings, lists, sets, and hashes, you can also store advanced\ndata structures such as RedisJSON for documents, RediSearch for secondary indexing, RedisGraph for graph data,\nRedisTimeSeries for time-series data, and RedisBloom for probabilistic data (think leaderboards)."),(0,i.kt)("p",null,"This reduces impedance mismatch because your data is stored in one of 15 structures with little or no transformations.\nYou can also use a single connection (or connection pool) and client library to access your data. What you end up with is\na simplified architecture with purpose-built models that are blazing fast and simple to manage. For this reason, this e-book\nwill use Redis to explain several of the NoSQL data modeling patterns."),(0,i.kt)("p",null,"Most developers have at least a little understanding of SQL and how to model data in it. This is because SQL is widely\nused and there are several incredible books and even full courses devoted to it. NoSQL is quickly growing and becoming\nmore popular. But given that when you\u2019re talking about NoSQL you\u2019re talking about more than just a document store, there\nis a lot of ground to cover. That\u2019s why when covering certain NoSQL data modeling patterns in this e-book, you will be\npresented with what it might look like to model the data in SQL as well."),(0,i.kt)("p",null,"When you approach data modeling in SQL you are typically focused on relationships, as SQL is meant for set-based\noperations on relational data. NoSQL doesn\u2019t have this constraint and is more flexible in the way you model data.\nHowever, this can lead to schemas that are overly complex. When considering NoSQL schema design, always think about\nperformance and try to keep things simple."),(0,i.kt)("p",null,"So to kick things off, let\u2019s start by looking at something that is very near and dear to a SQL developer\u2019s heart: ",(0,i.kt)("strong",{parentName:"p"},"relationships"),"."),(0,i.kt)("h2",{id:"modeling-1-to-1-relationships"},"Modeling 1-to-1 Relationships"),(0,i.kt)("p",null,"Imagine that you are creating a retail app that sells electronics. Let\u2019s use ",(0,i.kt)("strong",{parentName:"p"},"Picture 1")," and ",(0,i.kt)("strong",{parentName:"p"},"Picture 2")," as an example of the\nUI for a standard retail e-commerce app. First, you\u2019ll create a list view of all the electronics and then a detailed view\nthat shows all the details of each item. There is a 1-to-1 relationship between each item in the list view and the detailed\nview (shown in ",(0,i.kt)("strong",{parentName:"p"},"Picture 2"),") of the item. The detailed view shows all the details such as multiple photos, description,\nmanufacturer, dimensions, weight, and so on."),(0,i.kt)("div",{className:"container"},(0,i.kt)("div",{className:"row"},(0,i.kt)("div",{className:"col col--6"},(0,i.kt)("strong",null,"Picture 1"),(0,i.kt)("img",{src:"/img/ebooks/nosql-data-modeling-patterns/1-to-1-list-view.png",alt:"Picture 1 1-to-1 List View",title:"Picture 1 1-to-1 List View"})),(0,i.kt)("div",{className:"col col--6"},(0,i.kt)("strong",null,"Picture 2"),(0,i.kt)("img",{src:"/img/ebooks/nosql-data-modeling-patterns/1-to-1-detail-view.png",alt:"Picture 2 1-to-1 Detailed View",title:"Picture 2 1-to-1 Detailed View"})))),(0,i.kt)("h3",{id:"1-to-1-relationships-using-sql"},"1-to-1 Relationships using SQL"),(0,i.kt)("p",null,"In a relational database, you may create a table called ",(0,i.kt)("inlineCode",{parentName:"p"},"products")," where each row holds just enough data to display the information in the list view. Then, you may create another table called ",(0,i.kt)("inlineCode",{parentName:"p"},"product_details")," where each row holds the rest of the details. You would also need a ",(0,i.kt)("inlineCode",{parentName:"p"},"product_images")," table, where you store all of the images for a product. You can see the entity relationship diagram in ",(0,i.kt)("strong",{parentName:"p"},"Picture 3"),"."),(0,i.kt)("strong",null,"Picture 3"),(0,i.kt)("img",{src:"/img/ebooks/nosql-data-modeling-patterns/1-to-1-entity-diagram.png",alt:"Picture 3 1-to-1 Entity Diagram",title:"Picture 3 1-to-1 Entity Diagram"}),(0,i.kt)("p",null,"Picture 3 depicts the entity relationships between ",(0,i.kt)("inlineCode",{parentName:"p"},"products"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"product_details"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"product_images")," and represents a normalized data model with a single denormalized field image in the ",(0,i.kt)("inlineCode",{parentName:"p"},"products")," table. The reason for this is to avoid having to use a SQL JOIN when selecting the products for the list view. Using this model, the SQL query used to get the data needed for the list view might resemble ",(0,i.kt)("strong",{parentName:"p"},"Code Example 1"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql",metastring:'title="Code Example 1"',title:'"Code',Example:!0,'1"':!0},"SELECT\n    p.id, p.name, p.image, p.price, pi.url\nFROM\n    products p\n")),(0,i.kt)("h3",{id:"1-to-1-relationships-using-redis"},"1-to-1 Relationships using Redis"),(0,i.kt)("p",null,"In Redis, similar to a relational database, you can create a collection called ",(0,i.kt)("inlineCode",{parentName:"p"},"products")," and another called ",(0,i.kt)("inlineCode",{parentName:"p"},"product_details"),". But with RedisJSON you can improve this by simply embedding ",(0,i.kt)("inlineCode",{parentName:"p"},"product_images")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"product_details")," directly into the ",(0,i.kt)("inlineCode",{parentName:"p"},"Products")," collection. Then, when you query the ",(0,i.kt)("inlineCode",{parentName:"p"},"Products")," collection, specify which fields you need based on which view you are trying to create."),(0,i.kt)("p",null,"This will allow you to easily keep all the data in one place. This is called the ",(0,i.kt)("strong",{parentName:"p"},"Embedded Pattern")," and is one of the most common patterns you will see in NoSQL document databases like RedisJSON. ",(0,i.kt)("strong",{parentName:"p"},"Code Example 2")," uses Python and a client library called Redis OM (an ORM for Redis) to model ",(0,i.kt)("inlineCode",{parentName:"p"},"Products")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ProductDetails"),". Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"ProductDetails")," is embedded into ",(0,i.kt)("inlineCode",{parentName:"p"},"Products")," directly, so all of the data for a product will be stored within the same document."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Code Example 2"',title:'"Code',Example:!0,'2"':!0},"class ProductDetail(EmbeddedJsonModel):\n    description: str\n    manufacturer: str\n    dimensions: str\n    weight: str\n    images: List[str]\n\nclass Product(JsonModel):\n    name: str = Field(index=True)\n    image: str = Field(index=True)\n    price: int = Field(index=True)\n    details: Optional[ProductDetail]\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Code Example 2")," also shows how you can index fields using Redis OM and RediSearch. Doing this turns Redis into not only a document store but also a search engine since RediSearch enables secondary indexing and searching. When you create models using Redis OM, it will automatically manage secondary indexes with RediSearch on your behalf."),(0,i.kt)("p",null,"Using Redis OM we can write a function to retrieve our ",(0,i.kt)("inlineCode",{parentName:"p"},"products")," list for the list view, as shown in ",(0,i.kt)("strong",{parentName:"p"},"Code Example 3"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Code Example 3"',title:'"Code',Example:!0,'3"':!0},"async def get_product_list():\n    results = await connections \\\n        .get_redis_connection() \\\n        .execute_command(\n            f'FT.SEARCH {Product.Meta.index_name} * LIMIT 0 10 RETURN 3 name image price'\n        )\n    return Product.from_redis(results)\n")),(0,i.kt)("p",null,"Notice that in ",(0,i.kt)("strong",{parentName:"p"},"Code Example 3")," we are using the ",(0,i.kt)("inlineCode",{parentName:"p"},"FT.SEARCH")," (RediSearch) command, which specifies the index managed on our behalf by Redis OM and returns three fields: name, image, and price. While the documents all have details and images embedded, we don\u2019t want to display them in the list view so we don\u2019t need to query them. When we want the detailed view, we can query an entire Product document. See ",(0,i.kt)("strong",{parentName:"p"},"Code Example 4")," for how to query an entire document."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:'title="Code Example 4"',title:'"Code',Example:!0,'4"':!0},"async def get_product_details(product_id: str):\n    eturn await Product.get(product_id)\n")),(0,i.kt)("p",null,"When using Redis, you can use RedisInsight as a GUI tool to visualize and interact with the data in your database. ",(0,i.kt)("strong",{parentName:"p"},"Picture 4")," shows you what a ",(0,i.kt)("inlineCode",{parentName:"p"},"Products")," document looks like."),(0,i.kt)("strong",null,"Picture 4"),(0,i.kt)("img",{src:"/img/ebooks/nosql-data-modeling-patterns/1-to-1-redisinsight.png",alt:"Picture 4 1-to-1 RedisInsight",title:"Picture 4 1-to-1 RedisInsight"}),(0,i.kt)("h2",{id:"download-the-e-book"},"Download the E-book")))}m.isMDXComponent=!0}}]);