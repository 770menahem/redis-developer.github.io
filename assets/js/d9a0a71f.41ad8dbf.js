"use strict";(self.webpackChunkredis_developer_hub=self.webpackChunkredis_developer_hub||[]).push([[7678],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(a),h=r,g=u["".concat(l,".").concat(h)]||u[h]||d[h]||o;return a?n.createElement(g,i(i({ref:t},p),{},{components:a})):n.createElement(g,i({ref:t},p))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=a[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},30768:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var n=a(87462),r=(a(67294),a(3905));const o={id:"index-basic-caching",title:"How to add a basic API Cache to your ASP.NET Core application",sidebar_label:"Basic API Caching using ASP.NET Core",slug:"/develop/dotnet/aspnetcore/caching/basic-api-caching",authors:["steve"]},i=void 0,s={unversionedId:"develop/dotnet/aspnetcore/caching/basic/index-basic-caching",id:"develop/dotnet/aspnetcore/caching/basic/index-basic-caching",title:"How to add a basic API Cache to your ASP.NET Core application",description:"Redis is synonymous with caching, and for a good reason, Redis is fast and easy to get up and running with and does an excellent job as a cache.",source:"@site/docs/develop/dotnet/aspnetcore/caching/basic/index-basic-api-caching.md",sourceDirName:"develop/dotnet/aspnetcore/caching/basic",slug:"/develop/dotnet/aspnetcore/caching/basic-api-caching",permalink:"/develop/dotnet/aspnetcore/caching/basic-api-caching",draft:!1,editUrl:"https://github.com/redis-developer/redis-developer/edit/master/docs/develop/dotnet/aspnetcore/caching/basic/index-basic-api-caching.md",tags:[],version:"current",lastUpdatedAt:1655485542,formattedLastUpdatedAt:"Jun 17, 2022",frontMatter:{id:"index-basic-caching",title:"How to add a basic API Cache to your ASP.NET Core application",sidebar_label:"Basic API Caching using ASP.NET Core",slug:"/develop/dotnet/aspnetcore/caching/basic-api-caching",authors:["steve"]},sidebar:"docs",previous:{title:"Rate Limiting Middleware",permalink:"/develop/dotnet/aspnetcore/rate-limiting/middleware"},next:{title:"Getting Started",permalink:"/develop/dotnet/redis-om-dotnet/getting-started"}},l={},c=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Start Redis",id:"start-redis",level:2},{value:"Create the Project",id:"create-the-project",level:2},{value:"Add Redis Cache to ASP.NET Core app",id:"add-redis-cache-to-aspnet-core-app",level:2},{value:"Create Data Structures to Hold Results",id:"create-data-structures-to-hold-results",level:2},{value:"Dependency Injection Into the Weather Forecast Controller",id:"dependency-injection-into-the-weather-forecast-controller",level:2},{value:"Query the API",id:"query-the-api",level:2},{value:"Write the Forecast Action",id:"write-the-forecast-action",level:2},{value:"Run the App",id:"run-the-app",level:2},{value:"Resources",id:"resources",level:2}],p={toc:c};function d(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Redis is synonymous with caching, and for a good reason, Redis is fast and easy to get up and running with and does an excellent job as a cache."),(0,r.kt)("p",null,"There are two big reasons to use a cache over the source of truth."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Time - caches are much faster"),(0,r.kt)("li",{parentName:"ol"},"Cost - sometimes going to a source of truth has a monetary cost. For example, API endpoints sometimes charge per request. This means that we want to limit unnecessary requests to a particular endpoint.")),(0,r.kt)("p",null,"In the second case, unnecessary requests to the API endpoint are wasteful and can add up to a high financial cost to the application over time. Therefore, in this tutorial, we will look at caching the results of API requests to prevent us from having to make round trips to an API."),(0,r.kt)("p",null,"For our example, we will use the US National Weather Service's (NWS) Weather API - which is free and requires no authentication beyond a user-agent. We will build an API to get a weather forecast based on latitude and longitude using ASP.NET Core."),(0,r.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"IDE to write C# code - Visual Studio, Rider, VS Code, etc. . ."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://dotnet.microsoft.com/en-us/download/dotnet/6.0"},".NET 6 SDK")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.docker.com/products/docker-desktop"},"Docker"))),(0,r.kt)("h2",{id:"start-redis"},"Start Redis"),(0,r.kt)("p",null,"Let's start out by starting redis; for development purposes, you can just use docker:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"docker run -p 6379:6379 redis\n")),(0,r.kt)("p",null,"If you are getting ready to deploy to production, you may want to make use of the ",(0,r.kt)("a",{parentName:"p",href:"https://app.redislabs.com/"},"Redis Cloud")),(0,r.kt)("h2",{id:"create-the-project"},"Create the Project"),(0,r.kt)("p",null,"Next, we'll create the ASP.NET Core API project using the .NET CLI."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"dotnet new webapi -n BasicWeatherCacheApp\n")),(0,r.kt)("p",null,"Then we'll cd into the ",(0,r.kt)("inlineCode",{parentName:"p"},"BasicWeatherCacheApp")," directory that we just created, and we will add the ",(0,r.kt)("inlineCode",{parentName:"p"},"StackExchange.Redis")," package to the project:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"dotnet add package StackExchange.Redis\n")),(0,r.kt)("h2",{id:"add-redis-cache-to-aspnet-core-app"},"Add Redis Cache to ASP.NET Core app"),(0,r.kt)("p",null,"Open up the ",(0,r.kt)("inlineCode",{parentName:"p"},"program.cs")," file. This is where the services are all defined and injected into the project. Add the following to add the StackExchange.Redis ",(0,r.kt)("inlineCode",{parentName:"p"},"ConnectionMultiplexer")," Redis to the ASP.NET Core application as well as an HttpClient:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'builder.Services.AddSingleton<IConnectionMultiplexer>(ConnectionMultiplexer.Connect("localhost"));\nbuilder.Services.AddHttpClient();\n')),(0,r.kt)("h2",{id:"create-data-structures-to-hold-results"},"Create Data Structures to Hold Results"),(0,r.kt)("p",null,"The resulting structure from the NWS is a bit verbose, but we will endeavor to just capture the future forecasts for a particular area."),(0,r.kt)("p",null,"We'll create two structures, the first will contain the actual forecast, and the second will have the list of forecasts from a given request, as well as the time it took to accumulate the forecasts. For the first, we'll use the default ",(0,r.kt)("inlineCode",{parentName:"p"},"WeatherForecast")," class that's created in the template, open up ",(0,r.kt)("inlineCode",{parentName:"p"},"WeatherForecast.cs"),", and replace its contents with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'public class WeatherForecast\n{\n    [JsonPropertyName("number")]\n    public int Number { get; set; }\n\n    [JsonPropertyName("name")]\n    public string Name { get; set; }\n\n    [JsonPropertyName("startTime")]\n    public DateTime StartTime { get; set; }\n\n    [JsonPropertyName("endTime")]\n    public DateTime EndTime { get; set; }\n\n    [JsonPropertyName("isDayTime")]\n    public bool IsDayTime { get; set; }\n\n    [JsonPropertyName("temperature")]\n    public int Temperature { get; set; }\n\n    [JsonPropertyName("temperatureUnit")]\n    public string? TemperatureUnit { get; set; }\n\n    [JsonPropertyName("temperatureTrend")]\n    public string? TemperatureTrend { get; set; }\n\n    [JsonPropertyName("windSpeed")]\n    public string? WindSpeed { get; set; }\n\n    [JsonPropertyName("windDirection")]\n    public string? WindDirection { get; set; }\n\n    [JsonPropertyName("shortForecast")]\n    public string? ShortForecast { get; set; }\n\n    [JsonPropertyName("detailedForecast")]\n    public string? DetailedForecast { get; set; }\n}\n')),(0,r.kt)("p",null,"Next, create the file ",(0,r.kt)("inlineCode",{parentName:"p"},"ForecastResult.cs")," and add the following to it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public class ForecastResult\n{\n    public long ElapsedTime { get; }\n    public IEnumerable<WeatherForecast> Forecasts { get; }\n\n    public ForecastResult(IEnumerable<WeatherForecast> forecasts, long elapsedTime)\n    {\n        Forecasts = forecasts;\n        ElapsedTime = elapsedTime;\n    }\n}\n")),(0,r.kt)("h2",{id:"dependency-injection-into-the-weather-forecast-controller"},"Dependency Injection Into the Weather Forecast Controller"),(0,r.kt)("p",null,"Now that we've set up our app, we need to configure our controller. First, open the ",(0,r.kt)("inlineCode",{parentName:"p"},"Controllers/WeatherForecastController")," (this controller is automatically created along with the template) and add the following code to inject what we need into it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'private readonly HttpClient _client;\nprivate readonly IDatabase _redis;\n\npublic WeatherForecastController(HttpClient client, IConnectionMultiplexer muxer)\n{\n    _client = client;\n    _client.DefaultRequestHeaders.UserAgent.Add(new ProductInfoHeaderValue("weatherCachingApp","1.0") );\n    _redis = muxer.GetDatabase();\n}\n')),(0,r.kt)("h2",{id:"query-the-api"},"Query the API"),(0,r.kt)("p",null,"To query the Weather API to find the forecast for a particular latitude and longitude, we need to go through a 2 step process. First, there's no natural API for querying the forecast based on geolocation. Instead, every geolocation is assigned a particular office out of which it's monitored, and each office has a grid 2D grid that a specific latitude and longitude will map to. Fortunately, there's a ",(0,r.kt)("inlineCode",{parentName:"p"},"points")," API endpoint to which you can pass your latitude and longitude. This will give you the particular office out of which the point is valid and the x/y grid coordinates for that point. You need to query the forecast endpoint for that grid points for that office and then pull out the forecasted periods. The following accomplishes all this."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'private async Task<string> GetForecast(double latitude, double longitude)\n{\n    var pointsRequestQuery = $"https://api.weather.gov/points/{latitude},{longitude}"; //get the URI\n    var result = await _client.GetFromJsonAsync<JsonObject>(pointsRequestQuery);\n    var gridX = result["properties"]["gridX"].ToString();\n    var gridY = result["properties"]["gridY"].ToString();\n    var gridId = result["Properties"]["gridId"].ToString();\n    var forecastRequestQuery = $"https://api.weather.gov/gridpoints/{gridId}/{gridX},{gridY}/forecast";\n    var forecastResult = await _client.GetFromJsonAsync<JsonObject>(forecastRequestQuery);\n    var periodsJson = forecastResult["properties"]["periods"].ToJsonString();\n    return periodsJson;\n}\n')),(0,r.kt)("h2",{id:"write-the-forecast-action"},"Write the Forecast Action"),(0,r.kt)("p",null,"Given the multiple API Calls, it's clear why using a cache is critical for our application. These forecasts do not update very often, every 1-3 hours. That means making two back-to-back API requests can be expensive in both time and money. In the case of this API, there's no financial cost associated with the requests. However, with a commercial API, there often times will be per-request costs. When we are writing this action, we will check the cache. If the cache contains the relevant forecast, we will return that. Otherwise, we will hit the API, save the result, and set the key to expire. We'll time it and then reply back with the result and time it took."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'[HttpGet(Name = "GetWeatherForecast")]\npublic async Task<ForecastResult> Get([FromQuery] double latitude, [FromQuery] double longitude)\n{\n    string json;\n    var watch = Stopwatch.StartNew();\n    var keyName = $"forecast:{latitude},{longitude}";\n    json = await _redis.StringGetAsync(keyName);\n    if (string.IsNullOrEmpty(json))\n    {\n        json = await GetForecast(latitude, longitude);\n        var setTask = _redis.StringSetAsync(keyName, json);\n        var expireTask = _redis.KeyExpireAsync(keyName, TimeSpan.FromSeconds(3600));\n        await Task.WhenAll(setTask, expireTask);\n    }\n\n    var forecast =\n        JsonSerializer.Deserialize<IEnumerable<WeatherForecast>>(json);\n    watch.Stop();\n    var result = new ForecastResult(forecast, watch.ElapsedMilliseconds);\n\n    return result;\n}\n')),(0,r.kt)("h2",{id:"run-the-app"},"Run the App"),(0,r.kt)("p",null,"All that's left to do now is run the app. Run ",(0,r.kt)("inlineCode",{parentName:"p"},"dotnet run")," in your console, and open up to ",(0,r.kt)("inlineCode",{parentName:"p"},"https://localhost:PORT_NUMBER/swagger/index.html")," and use the GUI to send a request. Otherwise, you can use a cURL to send the request. The first time you send a new latitude and longitude, you'll notice that it takes pretty long to send the request, ~1 second. When you make the request again, and it hits the cache, it will drop dramatically to ~1-5ms."),(0,r.kt)("h2",{id:"resources"},"Resources"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Source code for this demo is located in ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/redis-developer/basic-aspnetcore-api-caching"},"GitHub")),(0,r.kt)("li",{parentName:"ul"},"More documentation for the StackExchange.Redis library is located on it's ",(0,r.kt)("a",{parentName:"li",href:"https://stackexchange.github.io/StackExchange.Redis/"},"docs site"))))}d.isMDXComponent=!0}}]);