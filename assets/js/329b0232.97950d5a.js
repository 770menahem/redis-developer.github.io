"use strict";(self.webpackChunkredis_developer_hub=self.webpackChunkredis_developer_hub||[]).push([[4275],{3905:(e,t,r)=>{r.d(t,{Zo:()=>d,kt:()=>p});var a=r(67294);function s(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function n(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?n(Object(r),!0).forEach((function(t){s(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,a,s=function(e,t){if(null==e)return{};var r,a,s={},n=Object.keys(e);for(a=0;a<n.length;a++)r=n[a],t.indexOf(r)>=0||(s[r]=e[r]);return s}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(a=0;a<n.length;a++)r=n[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(s[r]=e[r])}return s}var l=a.createContext({}),c=function(e){var t=a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var r=e.components,s=e.mdxType,n=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),m=c(r),p=s,g=m["".concat(l,".").concat(p)]||m[p]||u[p]||n;return r?a.createElement(g,o(o({ref:t},d),{},{components:r})):a.createElement(g,o({ref:t},d))}));function p(e,t){var r=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var n=r.length,o=new Array(n);o[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:s,o[1]=i;for(var c=2;c<n;c++)o[c]=r[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,r)}m.displayName="MDXCreateElement"},18760:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>n,metadata:()=>i,toc:()=>c});var a=r(87462),s=(r(67294),r(3905));const n={id:"blocking-reads",title:"Blocking Stream Reads",sidebar_label:"Blocking Stream Reads",slug:"/develop/dotnet/streams/blocking-reads",authors:["steve"]},o=void 0,i={unversionedId:"develop/dotnet/streams/blocking-reads/blocking-reads",id:"develop/dotnet/streams/blocking-reads/blocking-reads",title:"Blocking Stream Reads",description:"Redis Streams can be used to build a message bus for our applications. The ability of multiple readers to consume messages from a Redis Stream in a consumer group makes Redis Streams ideal for a variety of use cases where you want the assurance of message delivery and where you have high volumes of data you want to distribute across multiple consumers.",source:"@site/docs/develop/dotnet/streams/blocking-reads/blocking-reads.md",sourceDirName:"develop/dotnet/streams/blocking-reads",slug:"/develop/dotnet/streams/blocking-reads",permalink:"/develop/dotnet/streams/blocking-reads",draft:!1,editUrl:"https://github.com/redis-developer/redis-developer/edit/master/docs/develop/dotnet/streams/blocking-reads/blocking-reads.md",tags:[],version:"current",lastUpdatedAt:1655485542,formattedLastUpdatedAt:"Jun 17, 2022",frontMatter:{id:"blocking-reads",title:"Blocking Stream Reads",sidebar_label:"Blocking Stream Reads",slug:"/develop/dotnet/streams/blocking-reads",authors:["steve"]},sidebar:"docs",previous:{title:"Using Redis Streams with .NET",permalink:"/develop/dotnet/streams/stream-basics"},next:{title:"Blocking Stream Reads with ServiceStack.Redis",permalink:"/develop/dotnet/streams/blocking-reads/service-stack"}},l={},c=[],d={toc:c};function u(e){let{components:t,...r}=e;return(0,s.kt)("wrapper",(0,a.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://redis.io/topics/streams-intro"},"Redis Streams")," can be used to build a message bus for our applications. The ability of multiple readers to consume messages from a Redis Stream in a consumer group makes Redis Streams ideal for a variety of use cases where you want the assurance of message delivery and where you have high volumes of data you want to distribute across multiple consumers."),(0,s.kt)("p",null,"One of the great things about Redis Streams is that you can reduce the number of requests you need to make to Redis by having consumers use blocking requests and wait for new messages to come into the stream. In terms of commands, this would look something like this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"XREADGROUP GROUP average avg1 COUNT 1 BLOCK 1000 STREAMS numbers >\n")),(0,s.kt)("p",null,"Or, for a simple XREAD, you can wait for the next message to come in:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"127.0.0.1:6379> XREAD BLOCK 1000 STREAMS numbers $\n")),(0,s.kt)("p",null,"The main .NET Redis client ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/StackExchange/StackExchange.Redis"},"StackExchange.Redis")," does not support this particular feature. The reason for this lack of support is architectural, the StackExchange.Redis client centers all commands to Redis around a single connection. Because of this, blocking that connection for a single client will block all other requests to Redis. If we want to do blocking stream reads with Redis in .NET we'll need to use different clients to do so. Contained in this section are tutorials for doing so with both ",(0,s.kt)("a",{parentName:"p",href:"blocking-reads/service-stack"},"ServiceStack.Redis")," and ",(0,s.kt)("a",{parentName:"p",href:"blocking-reads/cs-redis"},"CsRedis")))}u.isMDXComponent=!0}}]);