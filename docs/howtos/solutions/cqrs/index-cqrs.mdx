---
id: index-solutions-cqrs
title: How to build an e-commerce app using Redis with the CQRS Pattern
sidebar_label: How to build an e-commerce app using Redis with the CQRS Pattern
slug: /howtos/solutions/cqrs
authors: [prasan, will]
---

import Authors from '@theme/Authors';
import cqrsPattern from './images/cqrs-pattern.png';

<Authors frontMatter={frontMatter} />

:::tip GITHUB CODE

Source code for the application used in this tutorial

https://github.com/redis-developer/redis-microservices-ecommerce-solutions
:::

## CQRS

Command and Query Responsibility Segregation (CQRS) is a common pattern used in event-driven applications in-part to allow for scaling read and write workloads independently. The idea is simple: you separate commands such as "Order this product" (update operation) from queries such as "Show me my order history" (write operation). CQRS applications are often messaging-based and rely on eventual consistency.

<!--temp img tag till replaced with dimensions-->

<img src={cqrsPattern} alt="CQRS pattern" width="500" />

## Why you might use CQRS

> _To improve application performance, scale your read and write operations separately._

Consider the following scenario. You have an e-commerce application that allows a customer to populate a shopping cart with products, and has a "Buy Now" button to facilitate ordering the products. When you first start out, you might setup a primary database like MongoDB and populate it with products. Then you might write a backend API to handle creating the order, creating an invoice, processing payment, handling fulfillment, and updating the customer's order history all in one go.

This method of synchronous order processing seems like a good idea, but you quickly find out that your database slows down as you gain more customers and have a higher sales volume. You decide that you need to **process orders** quickly so the customer doesn't have to wait. Then, when you have time you can create an invoice, process payment, handle fulfillment, etc. So you decide to separate each of these steps and use an event-driven approach with CQRS to allow you to scale your reads and writes separately.

## Ecommerce (event-driven) architecture

You eventually land on the following architecture:

1. `products service` - handles querying products from the database and returning them to the frontend
1. `orders service` - handles validating and creating orders
1. `order history service` - handles querying a customer's order history
1. `payments service` - handles processing orders for payment
1. `api gateway` - unifies your services under a single endpoint
1. `mongodb` - serves as the primary database, storing orders, order history, products, etc.

Here is what the architecture diagram looks like so far:

![Initial CQRS architecture](images/initial-cqrs-architecture.png)

## Using CQRS in an event-driven architecture

However, note that in the current architecture all the services use the same underlying database. Even though we are technically separating reads and writes, we can't scale our database independently. This is where Redis comes in. If we put Redis in front of our primary database, we can use it for reads while writing to the primary database. The benefit of Redis is that it is fast for reads and writes, which is why it is the defacto choice for caching. Our architecture now might look like the following:

![CQRS architecture with Redis](images/cqrs-architecture-with-redis.png)

What is not depicted in the images above is the events happening to coordinate communication between the services. This is covered in the [interservice communication guide](/howtos/solutions/interservice-communication). For now, let's look at some sample code that helps facilitate the CQRS pattern with Redis and MongoDB.

## Ecommerce product

Consider below e-commerce application,

- Dashboard to populate list of products

  [TODO: dashboard image]

- Shopping Cart to view added products
  ![Shopping app frontend with Redis and MongoDB](images/frontend-cqrs-app-with-redis-and-mongodb.png)

- Order confirmation page

  [TODO: payment confirmation image]

- Order history view (on Orders tab click in the top nav bar)

  [TODO: order history image]

You can find the full source code for the app pictured above here. The frontend is build using **Next.js**, the backend is in **Node.js**, data is stored in **MongoDB** and **Redis**.

:::tip GITHUB CODE

Source code for the application

https://github.com/redis-developer/redis-microservices-ecommerce-solutions
:::

## Sample CQRS application with Redis and MongoDB

Let's consider sample code for `order service` to see the `CreateOrder` API (a write operation) and 'order history service' to see the `viewOrderHistory` API (a read operation)

### Create Order API

Below you will find an example API request and response to create an order.

#### Create Order Request

```json
// POST http://api-gateway/orders/createOrder
{
  "products": [
    {
      "productId": 11000,
      "qty": 2,
      "productPrice": 3995
    },
    {
      "productId": 11001,
      "qty": 1,
      "productPrice": 5450
    }
  ]
}
```

#### Create Order Response

```json
{
  "data": "63f5f8dc3696d145a45775a6", // orderId
  "error": null
}
```

When you make a request, it goes through the API gateway to the `orders service`. Ultimately it ends up calling a `createOrder` function which looks as follows:

```typescript
async function createOrder(order: IOrder) {
  if (!order) {
    throw 'Order data is mandatory!';
  }

  order.orderStatusCode = ORDER_STATUS.CREATED;
  order.userId = USERS.DEFAULT; // Used as a shortcut, in a real app you would use customer session data to fetch user details
  order.createdOn = new Date();
  order.createdBy = order.userId;
  order.lastUpdatedOn = null;
  order.lastUpdatedBy = null;
  order.statusCode = DB_ROW_STATUS.ACTIVE;

  order = await validateOrder(order);

  const orderId = await addOrderToRedis(order);
  order.orderId = orderId;

  await addOrderToMongoDB(order);

  return orderId;
}
```

:::info
For simplicity, we are adding data to both MongoDB & Redis in same service. Instead we can add data to any one store and use synchronization technique to sync with other.
For eg: You might consider using **RedisGears** to handle sync between Redis and mongodb in the background.

For the purposes of this tutorial we are not going to outline exactly how you might do synchronization, but instead focus on how the data is stored and accessed in Redis.
:::

Note above that we are calling the `addOrderToRedis` function to store our orders in Redis. Below is what that function looks like:

```typescript title="server/src/services/orders"
import { Entity, Schema } from 'redis-om';
import { getRedisOmClient } from '../utils/redis/redis-wrapper';

class OrderEntity extends Entity {}

const schema = new Schema(OrderEntity, {
  orderId: { type: 'string' },
  userId: { type: 'string' },
  orderStatusCode: { type: 'number' },

  productsStr: { type: 'string' },

  createdOn: { type: 'date' },
  createdBy: { type: 'string' },
  lastUpdatedOn: { type: 'date' },
  lastUpdatedBy: { type: 'string' },
  statusCode: { type: 'number' },
});

async function addOrderToRedis(order: IOrder) {
  let orderId = '';

  const redisOmClient = getRedisOmClient();
  const repository = redisOmClient.fetchRepository(schema);
  const entity = repository.createEntity(order);

  orderId = entity.entityId;
  entity.orderId = orderId;

  await repository.save(entity);

  return orderId;
}
```

We're using Redis OM for Node.js to store the order entities in Redis.

### Order History API

Below you will find an example API request and response to get a customer's order history.

#### Order History Request

```json
// GET http://api-gateway/orderHistory/viewOrderHistory
```

#### Order History Response

```json
{
  "data": [
    {
      "orderId": "01GTH7JTQWP5QSEY32NNKT6B88",
      "userId": "ADMIN",
      "orderStatusCode": 1,
      "products": [
        {
          "productId": 11000,
          "qty": 10,
          "productPrice": 3995,
          "productData": {
            "id": 11000,
            "price": 3995,
            "productDisplayName": "Puma Men Slick 3HD Yellow Black Watches",
            "variantName": "Slick 3HD Yellow",
            "brandName": "Puma",
            "ageGroup": "Adults-Men",
            "gender": "Men",
            "displayCategories": "Accessories",
            "styleImages": {
              "default": {
                "imageURL": "http://cdn_service/images/11000.jpg"
              }
            },
            "productDescriptors": {
              "description": {
                "value": "Stylish and comfortable, this motor sport inspired wrist watch from puma is designed with a plastic case and ..."
              }
            }
          }
        },
        {
          "productId": 11001,
          "qty": 19,
          "productPrice": 5450,
          "productData": {
            "id": 11001,
            "price": 5450,
            "productDisplayName": "Puma Men Top Fluctuation Red Black Watches",
            "variantName": "Top Fluctuation Red",
            "brandName": "Puma",
            "ageGroup": "Adults-Men",
            "gender": "Men",
            "displayCategories": "Accessories",
            "styleImages": {
              "default": {
                "imageURL": "http://cdn_service/images/11001.jpg"
              }
            },
            "productDescriptors": {
              "description": {
                "value": "This watch from puma comes in a clean sleek design. This active watch is perfect for urban wear and ..."
              }
            }
          }
        }
      ],
      "createdOn": "2023-03-02T13:18:31.657Z",
      "createdBy": "ADMIN",
      "lastUpdatedOn": null,
      "lastUpdatedBy": null
    }
    //...
  ],
  "error": null
}
```

When you make a request, it goes through the API gateway to the `order history service`. Ultimately it ends up calling a `viewOrderHistory` function which looks as follows:

```typescript title="server/src/services/order-history"
async function viewOrderHistory(userId: string) {
  const repository = OrderRepo.getRepository();
  let orders: IOrder[] = [];

  const result = repository
    .search()
    .where('createdBy')
    .eq(userId)
    .and('orderStatusCode')
    .gte(ORDER_STATUS.CREATED) //gte returns CREATED and PAYMENT_SUCCESS
    .and('statusCode')
    .eq(DB_ROW_STATUS.ACTIVE)
    .return.all();

  orders = result.map((elm) => {
    return {
      orderId: elm.orderId,
      userId: elm.userId,
      orderStatusCode: elm.orderStatusCode,
      createdOn: elm.createdOn,
      createdBy: elm.createdBy,
      lastUpdatedOn: elm.lastUpdatedOn,
      lastUpdatedBy: elm.lastUpdatedBy,
    } as IOrder;
  });

  return orders;
}
```

:::info

Note that the `order history service` only needs to go to Redis for all orders. This is because we are handling storing and synchronizing between Redis and MongoDB within the `orders service`.

:::

You might be used to using Redis as a cache and both storing and retrieving stringified JSON values or perhaps hashed values. However, if you look closely at the code above we are storing orders as JSON documents, and then using Redis OM to search for the orders belonging to a specific user. So in reality Redis is operating like a database and providing the ability to speed up queries and scale independently from the primary database (MongoDB in this case).

## Conclusion

Hopefully this tutorial has helped you visualize how you might use Redis with the CQRS pattern to help reduce the load on your primary database while still allowing you to store and search JSON documents. See below for some additional resources around this topic.

### Additional Resources

- [Interservice communication](/howtos/solutions/interservice-communication)
- [Query caching](/howtos/solutions/caching)
- [API gateway caching](/howtos/solutions/api-gateway-caching)
