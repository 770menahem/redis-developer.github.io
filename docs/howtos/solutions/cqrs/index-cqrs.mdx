---
id: index-solutions-cqrs
title: How to build an e-commerce app using Redis with the CQRS Pattern
sidebar_label: How to build an e-commerce app using Redis with the CQRS Pattern
slug: /howtos/solutions/cqrs
authors: [prasan, will]
---

import Authors from '@theme/Authors';
import MicroservicesEcommerceDesign from '../common-data/microservices-ecommerce.mdx';
import InitialMicroservicesArchitecture from '../common-data/microservices-arch.mdx';
import SourceCode from '../common-data/microservices-source-code-tip.mdx';
import RedisEnterprise from '../common-data/redis-enterprise.mdx';

import cqrsPattern from './images/cqrs-pattern.png';

<Authors frontMatter={frontMatter} />

<SourceCode />

## What is Command and Query Responsibility Segregation (CQRS)?

CQRS is a common pattern used in microservices applications in part to allow for scaling read and write workloads independently. The idea is simple: you separate commands such as "Order this product" (write operation) from queries such as "Show me my order history" (read operation). CQRS applications are often messaging-based and rely on eventual consistency. Below you will find a sample data architecture that demonstrates how Redis is used with CQRS.

<!--temp img tag till image resized with specific dimensions-->

<img src={cqrsPattern} alt="CQRS pattern" width="500" />

## Why You Might Use CQRS

> _To improve application performance, scale your read and write operations separately._

Consider the following scenario. You have an e-commerce application that allows a customer to populate a shopping cart with products, and has a "Buy Now" button to facilitate ordering the products. When you first start out, you might set up a primary database like MongoDB and populate it with products. Then you might write a backend API to handle creating the order, creating an invoice, processing payment, handling fulfillment, and updating the customer's order history all in one go.

This method of synchronous order processing seems like a good idea, but you quickly find out that your database slows down as you gain more customers and have a higher sales volume. The reality is, most applications have significantly more reads than writes, and you want to be able to scale those operations separately. You decide that you need to process orders quickly so the customer doesn't have to wait. Then, when you have time you can create an invoice, process payment, handle fulfillment, etc. So you decide to separate each of these steps and use a microservices approach with CQRS to allow you to scale your reads and writes independently.

## Microservices Architecture for an E-commerce Application

<InitialMicroservicesArchitecture />

## Using CQRS in a Microservices Architecture

Note that in the current architecture all the services use the same underlying database. Even though we are technically separating reads and writes, we can't scale our primary database independently. This is where Redis comes in. If we put Redis in front of our primary database, we can use it for reads while writing to the primary database. The benefit of Redis is that it is fast for reads and writes, which is why it is the de facto choice for caching and CQRS. Our new architecture looks as follows:

![CQRS architecture with Redis](images/cqrs-architecture-with-redis.png)

What is not depicted in the images above is the events happening to coordinate communication between the services. This is covered in the [interservice communication guide](/howtos/solutions/interservice-communication). For now, let's look at some sample code that helps facilitate the CQRS pattern with Redis and MongoDB.

## E-commerce Application Frontend using Next.js and Tailwind

<MicroservicesEcommerceDesign />

## Building a CQRS Microservices Application with Redis and MongoDB

Let's look at the sample code for the `order service` and see the `CreateOrder` command (a write operation). Then we'll look at the `order history service` to see the `ViewOrderHistory` command (a read operation).

### Create Order Command API

Below you will find an example API request and response to create an order.

#### Create Order Request

```json
// POST http://api-gateway/orders/createOrder
{
  "products": [
    {
      "productId": 11000,
      "qty": 2,
      "productPrice": 3995
    },
    {
      "productId": 11001,
      "qty": 1,
      "productPrice": 5450
    }
  ]
}
```

#### Create Order Response

```json
{
  "data": "63f5f8dc3696d145a45775a6", // orderId
  "error": null
}
```

When you make a request, it goes through the API gateway to the `orders service`. Ultimately it ends up calling a `createOrder` function which looks as follows:

```typescript
async function createOrder(order: IOrder) {
  if (!order) {
    throw 'Order data is mandatory!';
  }

  order.orderStatusCode = ORDER_STATUS.CREATED;
  order.userId = USERS.DEFAULT; // Used as a shortcut, in a real app you would use customer session data to fetch user details
  order.createdOn = new Date();
  order.createdBy = order.userId;
  order.lastUpdatedOn = null;
  order.lastUpdatedBy = null;
  order.statusCode = DB_ROW_STATUS.ACTIVE;

  order = await validateOrder(order);

  const orderId = await addOrderToRedis(order);
  order.orderId = orderId;

  await addOrderToMongoDB(order);

  return orderId;
}
```

:::info

For simplicity, we are adding data to both MongoDB and Redis in the same service. Another common pattern is to have your API interact with one database, and then separately use a synchronization mechanism to update the other database. For example, you could write directly to Redis, then use **RedisGears** to handle synchronizing Redis and MongoDB in the background. For the purposes of this tutorial we are not going to outline exactly how you might handle synchronization, but instead focus on how the data is stored and accessed in Redis.

:::

Note above that we are calling the `addOrderToRedis` function to store orders in Redis. We're using [Redis OM for Node.js](https://github.com/redis/redis-om-node) to store the order entities in Redis. Below is what that function looks like:

```typescript title="server/src/services/orders"
import { Entity, Schema } from 'redis-om';
import { getRedisOmClient } from '../utils/redis/redis-wrapper';

class OrderEntity extends Entity {}

const schema = new Schema(OrderEntity, {
  orderId: { type: 'string' },
  userId: { type: 'string' },
  orderStatusCode: { type: 'number' },

  productsStr: { type: 'string' },

  createdOn: { type: 'date' },
  createdBy: { type: 'string' },
  lastUpdatedOn: { type: 'date' },
  lastUpdatedBy: { type: 'string' },
  statusCode: { type: 'number' },
});

async function addOrderToRedis(order: IOrder) {
  let orderId = '';

  const redisOmClient = getRedisOmClient();
  const repository = redisOmClient.fetchRepository(schema);
  const entity = repository.createEntity(order);

  orderId = entity.entityId;
  entity.orderId = orderId;

  await repository.save(entity);

  return orderId;
}
```

### Order History API

Below you will find an example API request and response to get a customer's order history.

#### Order History Request

```json
// GET http://api-gateway/orderHistory/viewOrderHistory
```

#### Order History Response

```json
{
  "data": [
    {
      "orderId": "01GTH7JTQWP5QSEY32NNKT6B88",
      "userId": "ADMIN",
      "orderStatusCode": 1,
      "products": [
        {
          "productId": 11000,
          "qty": 10,
          "productPrice": 3995,
          "productData": {
            "id": 11000,
            "price": 3995,
            "productDisplayName": "Puma Men Slick 3HD Yellow Black Watches",
            "variantName": "Slick 3HD Yellow",
            "brandName": "Puma",
            "ageGroup": "Adults-Men",
            "gender": "Men",
            "displayCategories": "Accessories",
            "styleImages": {
              "default": {
                "imageURL": "http://cdn_service/images/11000.jpg"
              }
            },
            "productDescriptors": {
              "description": {
                "value": "Stylish and comfortable, this motor sport inspired wrist watch from puma is designed with a plastic case and ..."
              }
            }
          }
        },
        {
          "productId": 11001,
          "qty": 19,
          "productPrice": 5450,
          "productData": {
            "id": 11001,
            "price": 5450,
            "productDisplayName": "Puma Men Top Fluctuation Red Black Watches",
            "variantName": "Top Fluctuation Red",
            "brandName": "Puma",
            "ageGroup": "Adults-Men",
            "gender": "Men",
            "displayCategories": "Accessories",
            "styleImages": {
              "default": {
                "imageURL": "http://cdn_service/images/11001.jpg"
              }
            },
            "productDescriptors": {
              "description": {
                "value": "This watch from puma comes in a clean sleek design. This active watch is perfect for urban wear and ..."
              }
            }
          }
        }
      ],
      "createdOn": "2023-03-02T13:18:31.657Z",
      "createdBy": "ADMIN",
      "lastUpdatedOn": null,
      "lastUpdatedBy": null
    }
    //...
  ],
  "error": null
}
```

When you make a request, it goes through the API gateway to the `order history service`. Ultimately it ends up calling a `viewOrderHistory` function which looks as follows:

```typescript title="server/src/services/order-history"
async function viewOrderHistory(userId: string) {
  const repository = OrderRepo.getRepository();
  let orders: IOrder[] = [];

  const result = repository
    .search()
    .where('createdBy')
    .eq(userId)
    .and('orderStatusCode')
    .gte(ORDER_STATUS.CREATED) //gte returns CREATED and PAYMENT_SUCCESS
    .and('statusCode')
    .eq(DB_ROW_STATUS.ACTIVE)
    .return.all();

  orders = result.map((elm) => {
    return {
      orderId: elm.orderId,
      userId: elm.userId,
      orderStatusCode: elm.orderStatusCode,
      createdOn: elm.createdOn,
      createdBy: elm.createdBy,
      lastUpdatedOn: elm.lastUpdatedOn,
      lastUpdatedBy: elm.lastUpdatedBy,
    } as IOrder;
  });

  return orders;
}
```

:::info

Note that the `order history service` only needs to go to Redis for all orders. This is because we are handling storage and synchronization between Redis and MongoDB within the `orders service`.

:::

You might be used to using Redis as a cache and both storing and retrieving stringified JSON values or perhaps hashed values. However, if you look closely at the code above we are storing orders as JSON documents, and then using [Redis OM](https://github.com/redis/redis-om-node) to search for the orders belonging to a specific user. So in reality Redis is operating like a search engine and providing the ability to speed up queries and scale independently from the primary database (MongoDB in this case).

## Conclusion

Hopefully this tutorial has helped you visualize how you might use Redis with the CQRS pattern to help reduce the load on your primary database while still allowing you to store and search JSON documents. See below for some additional resources around this topic.

### Additional Resources

- [Interservice communication](/howtos/solutions/interservice-communication)
- [Query caching](/howtos/solutions/caching)
- [API gateway caching](/howtos/solutions/api-gateway-caching)
- [Redis YouTube channel](https://www.youtube.com/c/Redisinc)
- Clients like [Node Redis](https://github.com/redis/node-redis) and [Redis om Node](https://github.com/redis/redis-om-node) help you to use Redis in Node.js applications.

## Learn More

<RedisEnterprise />
