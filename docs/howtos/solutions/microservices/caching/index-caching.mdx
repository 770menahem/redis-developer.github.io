---
id: index-solutions-caching
title: How to use Redis for Query Caching
sidebar_label: How to use Redis for Query Caching
slug: /howtos/solutions/microservices/caching
authors: [prasan, will]
---

import Authors from '@theme/Authors';
import MicroservicesEcommerceDesign from '../common-data/microservices-ecommerce.mdx';
import MicroservicesArchitectureWithRedis from '../common-data/microservices-arch-with-redis.mdx';
import SourceCode from '../common-data/microservices-source-code-tip.mdx';
import RedisEnterprise from '../common-data/redis-enterprise.mdx';

import cacheMissImage from './images/redis-cache-aside-cache-miss.png';
import cacheHitImage from './images/redis-cache-aside-cache-hit.png';

<Authors frontMatter={frontMatter} />

<SourceCode />

## What is Query Caching?

Have you ever been in a situation where your database queries are slowing down, and you need to speed them up while keeping costs down? Imagine that you've built an e-commerce application that started small and is growing fast.

You're at the point where you have an extensive product catalog and millions of customers. Your queries to MongoDB are beginning to slow down, and you've already attempted to optimize them. Even though you were able to squeak out a little extra performance, it wasn't enough to satisfy your customers.

## Why You Should Use Redis for Query Caching

Redis is an in-memory datastore, making it perfect for caching. It allows you to reduce the load on your primary database while speeding up database reads.

For example, in an e-commerce application you might be able to guess what query is requested most often... If you guessed the query for searching products you would be correct!

To improve product search in ecommerce app, we can implement one of following caching patterns

- **Cache prefetching**: An entire product catalog can be pre-cached in Redis and the application can perform any product query on Redis similar to the primary database
- **Cache-aside** pattern: Redis is filled on-demand based on whatever search parameters are requested by the frontend.

:::tip

If you're using **Redis Enterprise** cache prefetching is made easier with support for JSON and search. You also get additional features such as real-time performance, infinite scalability, resiliency and fault tolerance, and high-availability features such as Active-Active geo-redundancy.

:::

This tutorial focuses on the **cache-aside** pattern. The goal of this design pattern is to set up **optimal** caching (load as you go) for better read operations. With caching, you might be familiar with "cache miss," where you do not find data in the cache, and a "cache hit," where you are able to find data in the cache. Let's look at how the cache aside pattern works with Redis for both a "cache miss" and a "cache hit."

### Cache-aside with Redis (cache miss)

<img
  src={cacheMissImage}
  alt="Cache miss when using the cache-aside pattern with Redis"
  width="500"
  className="margin-bottom--md"
/>

The image above depicts the steps taken in the cache-aside pattern when there is a "cache miss." To understand how this functions, consider the following process:

1. An application requests data from the backend
1. The backend checks to find out if the data is available in Redis
1. Data is not found (a cache miss), so the data is fetched from the database
1. The data returned from the database is subsequently stored in Redis
1. The data is then returned to the application

### Cache-aside with Redis (cache hit)

Now that you have seen what a "cache miss" looks like, let's cover a "cache hit." Below is the same diagram, with the "cache hit" steps highlighted in green.

<img
  src={cacheHitImage}
  alt="Cache hit when using the cache-aside pattern with Redis"
  width="500"
  className="margin-bottom--md"
/>

1. An application requests data from the backend
1. The backend checks to find out if the data is available in Redis
1. The data is then returned to the application

The cache-aside pattern is useful when you need to:

1. **Query data frequently** - When you have a large volume of reads (as is the case in an e-commerce app), the cache-aside pattern will give you an immediate performance gain for subsequent data requests.
1. **Fill the cache on-demand** - The cache-aside pattern will fill the cache as data is requested rather than pre-caching, thus saving on space and cost. Useful when it isn't clear what data will need to be cached.
1. **Be cost conscious** - Since cache size is directly related to the cost of cache storage in the cloud, the smaller the size, the less you pay.

:::tip

If you're using **Redis Enterprise** and a database that uses a JDBC driver, you can take advantage of [**Redis Smart Cache**](https://github.com/redis-field-engineering/redis-smart-cache), which let's you add caching to your application without changing the code. [**Click here to learn more!**](https://github.com/redis-field-engineering/redis-smart-cache)

:::

## Microservices Architecture for an E-commerce Application

<MicroservicesArchitectureWithRedis />

## E-commerce Application Frontend using Next.js and Tailwind

<MicroservicesEcommerceDesign />

## Caching in a Microservices Application with Redis and MongoDB

In our sample application, the products service publishes an API for filtering products. Here is what a call to the API looks like:

### Get Products by Filter Request

```json
// POST http://localhost:3000/products/getProductsByFilter
{
  "productDisplayName": "puma"
}
```

### Get Products by Filter Response (Cache Miss)

```json {30}
{
  "data": [
    {
      "_id": 11000,
      "data": {
        "id": 11000,
        "price": 3995,
        "productDisplayName": "Puma Men Slick 3HD Yellow Black Watches",
        "variantName": "Slick 3HD Yellow",
        "brandName": "Puma",
        "ageGroup": "Adults-Men",
        "gender": "Men",
        "displayCategories": "Accessories",
        "styleImages": {
          "default": {
            "imageURL": "http://host.docker.internal:8080/images/11000.jpg"
          }
        },
        "productDescriptors": {
          "description": {
            "value": "Stylish and comfortable, this motor sport inspired wrist watch from puma is designed with a plastic case and ..."
          }
        }
      },
      "productId": 11000
    }
    //...
  ],
  "error": null,
  "isFromCache": false
}
```

### Get Products by Filter Response (Cache Hit)

```json {6}
{
  "data": [
    //...same data as above
  ],
  "error": null,
  "isFromCache": true // now the data comes from the cache rather DB
}
```

### Implementing Cache-aside with Redis and MongoDB

Below you will find the function used to search for products in MongoDB.

```typescript
async function getProductsByFilter(productFilter: IProductFilter) {
  const mongo = getMongodb();
  const filter: Document = {
    statusCode: {
      $eq: DB_ROW_STATUS.ACTIVE,
    },
  };

  if (productFilter && productFilter.productDisplayName) {
    filter['data.productDisplayName'] = {
      $regex: productFilter.productDisplayName,
      $options: 'i',
    };
  }

  const projection: IProduct = {
    productId: 1,
    data: {
      id: 1,
      price: 1,
      productDisplayName: 1,
      variantName: 1,
      brandName: 1,
      ageGroup: 1,
      gender: 1,
      displayCategories: 1,
      styleImages: {
        default: {
          imageURL: 1,
        },
      },
      productDescriptors: {
        description: {
          value: 1,
        },
      },
    },
  };

  const limit = 100;
  const sort = {};
  const products = await mongo.find(
    COLLECTIONS.PRODUCTS.collectionName,
    filter,
    projection,
    limit,
    sort,
  );
  return products;
}
```

If you're familiar with MongoDB, the code above should be pretty straightforward. We simply make a call to MongoDB to find products based on a filter on the `displayName` property of the product. We also define a projection object to specify which properties to get out of MongoDB. You can set up multiple columns for better fuzzy searching, but for the purposes of this tutorial it is simplified.

Now, using MongoDB directly without Redis will work for a while, and eventually start to slow down. That's why Redis is brought in to speed things up. The cache-aside pattern was chosen in order to balance performance with cost. The basic decision tree for cache-aside is as follows.

When the frontend requests products:

1. Form a hash with the contents of the request (i.e. the search parameters)
1. Check Redis to see if a value exists for the hash
1. Is there a cache hit? If data is found for the hash it is returned; the process stops here.
1. Is there a cache miss? When data is not found, it is read out of MongoDB and subsequently stored in Redis prior to being returned.

Below you will find the code used to implement the decision tree.

```typescript
const getHashKey = (_filter: Document) => {
  let retKey = '';
  if (_filter) {
    const text = JSON.stringify(_filter);
    retKey = crypto.createHash('sha256').update(text).digest('hex');
  }
  return 'CACHE_ASIDE_' + retKey;
};

router.post(API.GET_PRODUCTS_BY_FILTER, async (req: Request, res: Response) => {
  const body = req.body;
  // using node-redis
  const redis = getNodeRedisClient();

  //get data from redis
  const hashKey = getHashKey(req.body);
  const cachedData = await redis.get(hashKey);
  const docArr = cachedData ? JSON.parse(cachedData) : [];

  if (docArr && docArr.length) {
    result.data = docArr;
    result.isFromCache = true;
  } else {
    // get data from mongodb
    const dbData = await getProductsByFilter(body); //method shown earlier

    if (body && body.productDisplayName && dbData.length) {
      // set data in redis (no need to wait)
      redis.set(hashKey, JSON.stringify(dbData), {
        EX: 60, // cache expiration in seconds
      });
    }

    result.data = dbData;
  }

  res.send(result);
});
```

:::tip

You will need to decide what expiry or time to live (TTL) works best for your particular use-case.

:::

## Conclusion

That's all there is to it! You've now seen how to use Redis for caching with one of the most common caching patterns (cache-aside). It's possible to incrementally adopt Redis wherever needed with different strategies/ patterns. See below for some additional resources around microservices topic.

### Additional Resources

- [CQRS](/howtos/solutions/microservices/cqrs)
- [Interservice communication](/howtos/solutions/microservices/interservice-communication)
- [API gateway caching](/howtos/solutions/microservices/api-gateway-caching)
- [Redis YouTube channel](https://www.youtube.com/c/Redisinc)
- Clients like [Node Redis](https://github.com/redis/node-redis) and [Redis om Node](https://github.com/redis/redis-om-node) help you to use Redis in Node.js applications.
- [RedisInsight](https://redis.com/redis-enterprise/redis-insight/) : To view your Redis data or to play with raw Redis commands in the workbench
